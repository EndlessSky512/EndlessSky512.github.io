<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue木桶布局（图片自适应浏览器宽度排列）的实现方法</title>
    <link href="/blog/2022/04/06/vue%E6%9C%A8%E6%A1%B6%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BD%E5%BA%A6%E6%8E%92%E5%88%97%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2022/04/06/vue%E6%9C%A8%E6%A1%B6%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BD%E5%BA%A6%E6%8E%92%E5%88%97%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>先上效果：</p><p><img src="https://s2.loli.net/2022/04/06/VTYzGMj8Xw3SD12.png" alt="image-20220406220014994"></p><p>基本实现思路：</p><ol><li>监听浏览器的resize事件，实时获取到浏览器宽度</li><li>设置一个图片的基础高度(例如300px)，以此为基准把图片都缩放到这个高度</li><li>把图片依次加入同一行，如果宽度超过浏览器宽度了，开始下一步处理</li><li>把最后一张导致超出宽度的图片弹出，计算该行已有图片的宽度</li><li>根据面积相等原则，计算新的高度（新的高度 = 浏览器宽度 * 基础高度 / 总的宽度 ）</li><li>根据新高度和图片原始比例，计算出图片新的宽高</li><li>最后一行不足以铺满屏幕，进行特殊处理</li></ol><p>虽然步骤说起来挺简单，但其实实现起来还是有不少坑的，比如说图片计算新的宽高时记得把边距也算上，最后一行因为不满一行需要特殊处理，图片的比例计算等等</p><p>完整的代码如下，已加有注释，可直接当一个组件使用，传入的参数格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs json">imgs<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span> id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> url<span class="hljs-punctuation">:</span>&#x27;图片地址&#x27;<span class="hljs-punctuation">,</span> width<span class="hljs-punctuation">:</span> &#x27;图片宽度&#x27;<span class="hljs-punctuation">,</span> height<span class="hljs-punctuation">:</span> &#x27;图片高度&#x27; <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;newList.length&gt;0&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(row,index) in newList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;min-width:1100px;&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-box&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;img in row&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;img.id&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;&#x27;width&#x27;:img.width,&#x27;height&#x27;:img.height&#125;&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;&#x27;detail/&#x27;+img.id&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-image</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;img.url&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片加载失败&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;&#x27;width&#x27;:img.width,&#x27;height&#x27;:img.height&#125;&quot;</span> <span class="hljs-attr">lazy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-image</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;imgs&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">screenWidth</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">imgsData</span>: [], <span class="hljs-comment">// 实际操作的图片列表</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 添加监听浏览器resize事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    self.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      self.<span class="hljs-property">screenWidth</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        self.<span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          self.<span class="hljs-property">screenWidth</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;, <span class="hljs-number">100</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 转存传过来的props里的imgs数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    self.<span class="hljs-property">imgsData</span> = self.<span class="hljs-property">imgs</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">watch</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 监听浏览器宽度</span></span></span><br><span class="language-javascript"><span class="language-xml">    screenWidth (val) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenWidth</span> = val</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 宽度一旦发生变化就开始重新排列</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">realignImgs</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    newList () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 接收的参数是baseheight，图片的基础高度</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">realignImgs</span>(<span class="hljs-number">300</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 节流</span></span></span><br><span class="language-javascript"><span class="language-xml">    throttle (fn, wait, scope) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        fn.<span class="hljs-title function_">apply</span>(scope)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;, wait)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 处理数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    realignImgs (baseheight) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// baseheight是设置的基础高度，后面的高度都是根据这个基础上下浮动的</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> newList = []</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 设定一个浏览器宽度的最低值为1000px</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> screenWidth = <span class="hljs-title class_">Number</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenWidth</span>) &gt; <span class="hljs-number">1000</span> ? <span class="hljs-title class_">Number</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenWidth</span>) : <span class="hljs-number">1000</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 先把设定的基础高度当作行高</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> rowHeight = baseheight</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> arrRow = []</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> imgsData = []</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 深拷贝转储一下</span></span></span><br><span class="language-javascript"><span class="language-xml">      imgsData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imgsData</span>))</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 循环 计算每个图片的宽度</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgsData.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> item = imgsData[i]</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 计算图片的宽高比</span></span></span><br><span class="language-javascript"><span class="language-xml">        item.<span class="hljs-property">ratio</span> = <span class="hljs-title class_">Number</span>(item.<span class="hljs-property">width</span>) / <span class="hljs-title class_">Number</span>(item.<span class="hljs-property">height</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 新的宽度，算法是比例乘以行高</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> newWidth = <span class="hljs-built_in">parseInt</span>(item.<span class="hljs-property">ratio</span> * rowHeight)</span></span><br><span class="language-javascript"><span class="language-xml">        item.<span class="hljs-property">width</span> = newWidth</span></span><br><span class="language-javascript"><span class="language-xml">        item.<span class="hljs-property">height</span> = rowHeight</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 定义该行图片宽度之和</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> totalWidth = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">        arrRow.<span class="hljs-title function_">push</span>(item)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrRow.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          totalWidth += arrRow[i].<span class="hljs-property">width</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 如果该行加入的图片宽度大于了该行的宽度</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 就需要弹出最后一张图片，并更改前面的图片大小比例</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">if</span> (totalWidth &gt; screenWidth) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 把最后一张弹出，恢复原来的wholeWidth</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> lastImg = arrRow.<span class="hljs-title function_">pop</span>()</span></span><br><span class="language-javascript"><span class="language-xml">          totalWidth -= lastImg.<span class="hljs-property">width</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 利用面积相等原则，来计算新的高度</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> newHeight = screenWidth * rowHeight / totalWidth</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 这里是根据一行图片的数量，计算需要留出的边距</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> marginSpace = (arrRow.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">20</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 重新计算宽高，占满一行</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrRow.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 最后再把每张图片等比例缩小一点，以留出边距</span></span></span><br><span class="language-javascript"><span class="language-xml">            arrRow[i].<span class="hljs-property">width</span> = newHeight * arrRow[i].<span class="hljs-property">ratio</span> - marginSpace</span></span><br><span class="language-javascript"><span class="language-xml">            arrRow[i].<span class="hljs-property">height</span> = newHeight - (marginSpace / arrRow[i].<span class="hljs-property">ratio</span>)</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 放置完毕之前的图片之后，清空该图片队列</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 并将上一行溢出的图片 作为下一行的第一张</span></span></span><br><span class="language-javascript"><span class="language-xml">          newList.<span class="hljs-title function_">push</span>(arrRow)</span></span><br><span class="language-javascript"><span class="language-xml">          arrRow = []</span></span><br><span class="language-javascript"><span class="language-xml">          arrRow.<span class="hljs-title function_">push</span>(lastImg)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 单独处理未最后一行</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 遍历每一行，把每一行的长度都加起来，这样才能得出最后一行的元素数量</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newList.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        tmp += newList[i].<span class="hljs-property">length</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> lastRow = []</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = tmp; i &lt; imgsData.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 高度就以设置好的基础高度为基准了</span></span></span><br><span class="language-javascript"><span class="language-xml">        imgsData[i].<span class="hljs-property">height</span> = rowHeight</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 宽度也是按照比例算的</span></span></span><br><span class="language-javascript"><span class="language-xml">        imgsData[i].<span class="hljs-property">width</span> = imgsData[i].<span class="hljs-property">ratio</span> * rowHeight</span></span><br><span class="language-javascript"><span class="language-xml">        lastRow.<span class="hljs-title function_">push</span>(imgsData[i])</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      newList.<span class="hljs-title function_">push</span>(lastRow)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> newList</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.row</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">justify-content</span>: space-around;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-tag">a</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.img-box</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.img-box</span>&gt;<span class="hljs-selector-tag">img</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.img-box</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.05</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.img-box</span><span class="hljs-selector-pseudo">:hover</span>&gt;<span class="hljs-selector-tag">img</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.05</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的Flex布局</title>
    <link href="/blog/2022/04/01/css%E4%B8%AD%E7%9A%84Flex%E5%B8%83%E5%B1%80/"/>
    <url>/blog/2022/04/01/css%E4%B8%AD%E7%9A%84Flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Flex布局原理"><a href="#1-Flex布局原理" class="headerlink" title="1.Flex布局原理"></a>1.Flex布局原理</h3><p>flex是flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><ul><li>当父元素为flex布局，子元素的float、clear和vertical-align属性讲失效</li><li>伸缩布局=弹性布局-伸缩盒布局=弹性盒布局-flex布局</li></ul><p>采用flex布局的元素，称为flex容器(flex container)，它的所有子元素自动称为容器成员，称为Flex项目(flex item)</p><p><strong>flex布局原理就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</strong></p><h3 id="2-FLex布局父项常见属性"><a href="#2-FLex布局父项常见属性" class="headerlink" title="2.FLex布局父项常见属性"></a>2.FLex布局父项常见属性</h3><p>对父元素设置的属性：</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>flex-direction</td><td>设置主轴的方向</td></tr><tr><td>justify-content</td><td>设置主轴上的子元素排列方式</td></tr><tr><td>flex-warp</td><td>设置子元素是否换行</td></tr><tr><td>align-content</td><td>设置侧轴上的子元素的排列方式（多行）</td></tr><tr><td>align-items</td><td>设置侧轴上的子元素排列方式（单行）</td></tr><tr><td>flex-flow</td><td>复合属性，相当于同时设置了flex-direction和flex-warp</td></tr></tbody></table><h4 id="1-flex-direction设置主轴方向"><a href="#1-flex-direction设置主轴方向" class="headerlink" title="1)flex-direction设置主轴方向"></a>1)flex-direction设置主轴方向</h4><h5 id="1-主轴与侧轴"><a href="#1-主轴与侧轴" class="headerlink" title="1.主轴与侧轴"></a>1.主轴与侧轴</h5><p>在flex布局种，是分为主轴和侧轴两个方向，同样的叫法又：行和列、x轴和y轴</p><ul><li>默认主轴方向就是x轴方向，水平向右</li><li>默认侧轴方向就是y轴方向，水平向下</li></ul><p><img src="https://s2.loli.net/2022/03/31/u3wW95GxnviZYQg.png" alt="image-20220331190521216"></p><h5 id="2-属性值"><a href="#2-属性值" class="headerlink" title="2.属性值"></a>2.属性值</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）</p><p>注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>默认值从左到右</td></tr><tr><td>row-reverse</td><td>从右到左</td></tr><tr><td>column</td><td>从上到下</td></tr><tr><td>column-reverse</td><td>从下到上</td></tr></tbody></table><h4 id="2）justify-content设置主轴上的子元素排列方式"><a href="#2）justify-content设置主轴上的子元素排列方式" class="headerlink" title="2）justify-content设置主轴上的子元素排列方式"></a>2）justify-content设置主轴上的子元素排列方式</h4><p>justify-content属性定义了项目在主轴上的对齐方式</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值 从头部开始，如果主轴是x轴，则从左到右</td></tr><tr><td>flex-end</td><td>从尾部开始排列</td></tr><tr><td>center</td><td>在主轴居中对齐(如果主轴是x轴则水平居中)</td></tr><tr><td><strong>space-around</strong></td><td><strong>平分剩余空间</strong></td></tr><tr><td><strong>space-between</strong></td><td><strong>先两边贴边，再平分剩余空间</strong></td></tr></tbody></table><h4 id="3-flex-wrap设置子元素是否换行"><a href="#3-flex-wrap设置子元素是否换行" class="headerlink" title="3)flex-wrap设置子元素是否换行"></a>3)flex-wrap设置子元素是否换行</h4><p>默认情况下，项目都排在一条线（又称“轴线”）上，如果装不开，就会缩小子元素的宽度</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>nowrap</td><td>默认值，不换行</td></tr><tr><td>wrap</td><td>换行</td></tr></tbody></table><h4 id="4）align-items设置侧轴上的子元素排列方式（单行）"><a href="#4）align-items设置侧轴上的子元素排列方式（单行）" class="headerlink" title="4）align-items设置侧轴上的子元素排列方式（单行）"></a>4）align-items设置侧轴上的子元素排列方式（单行）</h4><p>只适合于子盒子单行的情况</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值 从上到下</td></tr><tr><td>flex-end</td><td>从下到上</td></tr><tr><td>center</td><td>挤在一起居中（垂直居中）</td></tr><tr><td><strong>strech</strong></td><td><strong>拉伸</strong></td></tr></tbody></table><p>设置拉伸且不设置高度，则高度与父盒子一致</p><h4 id="5）align-content设置侧轴上的子元素的排列方式（多行）"><a href="#5）align-content设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="5）align-content设置侧轴上的子元素的排列方式（多行）"></a>5）align-content设置侧轴上的子元素的排列方式（多行）</h4><p>设置子项再侧轴上的排列方式，并且只能用于子项出现<strong>换行</strong>的情况</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值 从上到下</td></tr><tr><td>flex-end</td><td>从下到上</td></tr><tr><td>center</td><td>挤在一起居中（垂直居中）</td></tr><tr><td><strong>strech</strong></td><td><strong>拉伸</strong></td></tr><tr><td><strong>space-around</strong></td><td><strong>子项在侧轴平分剩余空间</strong></td></tr><tr><td><strong>space-between</strong></td><td><strong>子项在侧轴先分布在两头，再平分剩余空间</strong></td></tr></tbody></table><h4 id="6）flex-flow"><a href="#6）flex-flow" class="headerlink" title="6）flex-flow"></a>6）flex-flow</h4><p>flex-flow属性是flex-direction和flex-wrap属性的符合属性</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>:row wrap; //等于<span class="hljs-attribute">flex-direction</span>:row; <span class="hljs-attribute">flex-wrap</span>: wrap;<br></code></pre></td></tr></table></figure><h3 id="3-flex布局子项常见属性"><a href="#3-flex布局子项常见属性" class="headerlink" title="3.flex布局子项常见属性"></a>3.flex布局子项常见属性</h3><h4 id="1-flex属性"><a href="#1-flex属性" class="headerlink" title="1)flex属性"></a>1)flex属性</h4><p>flex属性定义子项目分配剩余空间，用flex来表示占多少份数。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">item</span>&#123;<br>flex: &lt;<span class="hljs-built_in">number</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现圣杯布局：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">section</span>&#123; </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>:flex; <span class="hljs-comment">/*父元素设置flex布局*/</span></span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-comment">/* 左部分 */</span></span><br><span class="language-css">    <span class="hljs-selector-tag">section</span>&gt;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>:red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-comment">/* 中间部分 */</span></span><br><span class="language-css">    <span class="hljs-selector-tag">section</span>&gt;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/*设置flex，占满所有剩余空间*/</span></span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-comment">/* 右部分 */</span></span><br><span class="language-css">    <span class="hljs-selector-tag">section</span>&gt;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-align-self控制子项自己在侧轴上的排列方式"><a href="#2-align-self控制子项自己在侧轴上的排列方式" class="headerlink" title="2)align-self控制子项自己在侧轴上的排列方式"></a>2)align-self控制子项自己在侧轴上的排列方式</h4><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p><p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-attribute">align-self</span>:flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）order属性定义项目的顺序"><a href="#3）order属性定义项目的顺序" class="headerlink" title="3）order属性定义项目的顺序"></a>3）order属性定义项目的顺序</h4><p>数值越小越靠前，默认是0</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【vue学习笔记】五、路由</title>
    <link href="/blog/2022/03/23/%E3%80%90vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%94%E3%80%81%E8%B7%AF%E7%94%B1/"/>
    <url>/blog/2022/03/23/%E3%80%90vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%94%E3%80%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="五、路由"><a href="#五、路由" class="headerlink" title="五、路由"></a>五、路由</h3><h4 id="1）什么是路由"><a href="#1）什么是路由" class="headerlink" title="1）什么是路由"></a>1）什么是路由</h4><p>路由(router)就是对应关系，在前端中路由就是<code>Hash</code>地址和页面的对应关系</p><p>在SPA（单页面程序）项目中，不同功能之间的切换要以来于前端路由来完成</p><h4 id="2）前端路由的工作方式"><a href="#2）前端路由的工作方式" class="headerlink" title="2）前端路由的工作方式"></a>2）前端路由的工作方式</h4><ol><li>用户点击了页面上的路由链接</li><li>导致URL地址栏中的Hash值发生了变化</li><li>前端路由监听到了Hash地址的变化</li><li>前端路由把当前Hash地址对应的组件渲染到浏览器中</li></ol><p><img src="https://s2.loli.net/2022/03/23/jr4dDtMINE2okLB.png" alt="image-20220323182955186"></p><h4 id="3）实现简易的前端路由"><a href="#3）实现简易的前端路由" class="headerlink" title="3）实现简易的前端路由"></a>3）实现简易的前端路由</h4><p>使用动态组件+监听<code>window.onhashchange</code>事件</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">// 只要当前的 App 组件一被创建，就立即监听 window 对象的 onhashchange事件</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span>=（）=&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;监听到了 hash 地址的变化’, location.hash)</span><br><span class="hljs-string">    switch(location.hash) &#123;</span><br><span class="hljs-string">    case &#x27;</span>#/home<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">    this.comName = &#x27;</span><span class="hljs-title class_">Home</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">    break </span><br><span class="hljs-string">    case&#x27;</span>#/movie<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">    this.comName = &#x27;</span><span class="hljs-title class_">Movie</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">    break</span><br><span class="hljs-string">    case &#x27;</span>#/about<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">    this.comNamee = &#x27;</span><span class="hljs-title class_">About</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">    break</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4）vue-router"><a href="#4）vue-router" class="headerlink" title="4）vue-router"></a>4）vue-router</h4><p><code>vue-router</code>是vue官方给出的路由解决方案</p><h5 id="1-vue-router安装与配置的步骤"><a href="#1-vue-router安装与配置的步骤" class="headerlink" title="1.vue-router安装与配置的步骤"></a>1.vue-router安装与配置的步骤</h5><ol><li>安装vue-router包</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i vue-router<br></code></pre></td></tr></table></figure><ol start="2"><li>创建路由模块</li></ol><p>在src源代码目录下，新建<code>router/index.js</code>路由模块，并初始化如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.导入Vue和VueRouter的包</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-comment">//2.调用Vue.use()函数，把VueRouter安装为Vue的插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><br><span class="hljs-comment">//3.创建路由的实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>()<br><br><span class="hljs-comment">//4.向外共享路由的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><ol start="3"><li>导入并挂载路由模块</li></ol><p>在<code>main.js</code>下进行挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入路由模块，得到router的实例对象</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/index.js&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>    router <span class="hljs-comment">//挂载路由</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li>声明路由链接和占位符</li></ol><p>只要在项目中配置了<code>vue-router</code>就可以在<code>App.vue</code>里使用<code>router-view</code>这个组件了，它是一个占位符，代表要切换的区域</p><p>在<code>router/index.js</code>里的<code>VueRouter</code>构造函数里使用<code>routers</code>属性绑定<code>hash</code>地址与组件之间的对应关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(<br><span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//每一个对应关系都叫做一个路由规则</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/movie&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Movie</span>&#125;<br>    ]<br>)<br></code></pre></td></tr></table></figure><h5 id="2-router-link替代a链接"><a href="#2-router-link替代a链接" class="headerlink" title="2.router-link替代a链接"></a>2.router-link替代a链接</h5><p>在<code>vue-router</code>里可以使用<code>router-link</code>来代替<code>&lt;a&gt;</code>标签实现哈希地址的跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>&quot;/<span class="hljs-attr">home</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5）vue-router的常见用法"><a href="#5）vue-router的常见用法" class="headerlink" title="5）vue-router的常见用法"></a>5）vue-router的常见用法</h4><h5 id="1-路由重定向"><a href="#1-路由重定向" class="headerlink" title="1.路由重定向"></a>1.路由重定向</h5><p>路由重定向是指当用户访问A地址时，强制跳转到B地址，从而展示特定的组件页面（可以用来设置默认界面）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(<br><span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//每一个对应关系都叫做一个路由规则</span><br>    &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span>&#125;<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>&#125;,<br>    &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/movie&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Movie</span>&#125;<br>    ]<br>)<br></code></pre></td></tr></table></figure><h5 id="2-嵌套路由"><a href="#2-嵌套路由" class="headerlink" title="2.嵌套路由"></a>2.嵌套路由</h5><p>通过路由实现组件的嵌套展示，叫做嵌套路由</p><p>要实现嵌套路由，要通过<code>children</code>属性声明子路由规则</p><p>在<code>src/router/index.js</code>路由模块中，导入需要的组件，并使用<code>children</code>属性声明子路由规则：</p><p>注意子路由的路径不要加<code>/</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(<br><span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>    <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab1&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab1</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab2&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab2</span> &#125;,<br>    ]<br>    &#125;,<br>    ]<br>)<br></code></pre></td></tr></table></figure><p>默认子路由的显示方式可以父路由里加一个<code>redirect</code>重定向，也可以把path值设置为空字符串，则这条路由规则叫做默认子路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//重定向</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(<br><span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/about/tab1&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab1&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab1</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab2&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab2</span> &#125;,<br>    ]<br>    &#125;,<br>    ]<br>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//默认子路由</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(<br><span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/about/tab1&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab1</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab2&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tab2</span> &#125;,<br>    ]<br>    &#125;,<br>    ]<br>)<br></code></pre></td></tr></table></figure><h5 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3.动态路由"></a>3.动态路由</h5><p>动态路由是指将Hash地址中可变的部分定义为参数向，从而提高路由规则的复用性</p><p>在<code>vue-router</code>中使用英文的冒号<code>:</code>来定义路由的参数项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//动态路由</span><br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Moive</span> &#125;<br><br><span class="hljs-comment">//相当于将下面3个路由规则合并</span><br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/1&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Moive</span> &#125;,<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/2&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Moive</span> &#125;,<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/3&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Moive</span> &#125;,<br></code></pre></td></tr></table></figure><p>在<code>movie</code>组件中，通过<code>this.$route.params.id</code>来拿到传递的id值</p><h5 id="4-为路由规则开启props传参"><a href="#4-为路由规则开启props传参" class="headerlink" title="4.为路由规则开启props传参"></a>4.为路由规则开启props传参</h5><p>在绑定路由时，设置<code>props: true</code>即可开启props传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Moive</span> , <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span>&#125; <span class="hljs-comment">//此时在组件中可以通过props接收id</span><br></code></pre></td></tr></table></figure><h5 id="5-路由query和fullPath"><a href="#5-路由query和fullPath" class="headerlink" title="5.路由query和fullPath"></a>5.路由query和fullPath</h5><p>在hash地址中<code>?</code>后面的参数项，叫做查询参数</p><p>在路由参数对象中，需要使用<code>this.$route.query</code>来访问查询参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>&quot;/<span class="hljs-attr">moive</span>/<span class="hljs-attr">2</span>?<span class="hljs-attr">name</span>=<span class="hljs-string">zs&amp;age</span>=<span class="hljs-string">20</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>this</code>对象中的<code>path</code>属性只是路径部分，而<code>fullPath</code>是完整的地址</p><p>例如：</p><p><code> fullPath: /moive/2?name=zs&amp;age=20</code></p><p><code>path: /moive/2</code></p><h5 id="6-声明式导航-amp-编程式盗汗"><a href="#6-声明式导航-amp-编程式盗汗" class="headerlink" title="6.声明式导航 &amp; 编程式盗汗"></a>6.声明式导航 &amp; 编程式盗汗</h5><p>在浏览器中，点击链接实现导航的方式，叫做声明式导航，例如：</p><ul><li>普通网页中点击<code>&lt;a&gt;</code>链接、vue项目中点击<code>&lt;router-link&gt;</code>都属于声明式导航</li></ul><p>在浏览器中，调用API方法实现导航的方式，叫做编程式导航</p><ul><li>普通网页中调用<code>location.href</code>跳转到新页面的方式，属于编程式导航</li></ul><h6 id="6-1-vue-router中的编程式导航API"><a href="#6-1-vue-router中的编程式导航API" class="headerlink" title="6.1 vue-router中的编程式导航API"></a>6.1 vue-router中的编程式导航API</h6><p><code>vue-router</code>中常用的编程式导航API:</p><ul><li><code>this.$router.push(&#39;hash地址&#39;)</code><ul><li>跳转到指定hash地址，并增加一条历史记录</li></ul></li><li><code>this.$router.replace(&#39;hash地址&#39;)</code><ul><li>跳转到指定hash地址，并替换掉当前的历史记录</li></ul></li><li><code>this.$router.go(数值n)</code><ul><li>代表在浏览历史中前进和后退（前进为正，后退为负）</li><li>如果超过上限则原地不动</li><li>可以使用<code>this.$router.back()</code>、<code>this.$router.back()</code></li></ul></li></ul><p>编程式导航可以写在行内，但是一定不能带<code>this</code>否则会报错</p><h5 id="7-导航守卫"><a href="#7-导航守卫" class="headerlink" title="7.导航守卫"></a>7.导航守卫</h5><p>导航守卫可以控制路由的访问权限</p><p><img src="https://s2.loli.net/2022/03/23/nN1GkmtHeFIDjbT.png" alt="image.png"></p><h6 id="7-1全局前置守卫"><a href="#7-1全局前置守卫" class="headerlink" title="7.1全局前置守卫"></a>7.1全局前置守卫</h6><p>每次发生路由导航跳转时们都会触发全局前置守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建路由实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123; ... &#125;)<br>                              <br><span class="hljs-comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫”</span><br><span class="hljs-comment">//每次发生路由导航跳转的时候，都会自动触发fn这个“回调函数”</span><br>router.<span class="hljs-title function_">beforeEach</span>(fn)<br></code></pre></td></tr></table></figure><h6 id="7-2守卫方法的3个形参"><a href="#7-2守卫方法的3个形参" class="headerlink" title="7.2守卫方法的3个形参"></a>7.2守卫方法的3个形参</h6><p>全局前置守卫的回调函数中接收3个形参，格式为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建路由实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123; ... &#125;)<br>                              <br><span class="hljs-comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫”</span><br><span class="hljs-comment">//每次发生路由导航跳转的时候，都会自动触发fn这个“回调函数”</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>to是将要访问的路由的信息对象</li><li>from是将要离开的路由的信息对象</li><li>next是一个函数，调用next()表示放行，允许这次路由导航</li></ul><h6 id="7-3next函数的3种调用方式"><a href="#7-3next函数的3种调用方式" class="headerlink" title="7.3next函数的3种调用方式"></a>7.3next函数的3种调用方式</h6><p><img src="https://s2.loli.net/2022/03/23/XI2Mpj5NYOLGvfu.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【vue学习笔记】四、动态组件&amp;插槽&amp;自定义组件</title>
    <link href="/blog/2022/03/23/%E3%80%90vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6-%E6%8F%92%E6%A7%BD-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    <url>/blog/2022/03/23/%E3%80%90vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6-%E6%8F%92%E6%A7%BD-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="四、动态组件-amp-插槽-amp-自定义组件"><a href="#四、动态组件-amp-插槽-amp-自定义组件" class="headerlink" title="四、动态组件&amp;插槽&amp;自定义组件"></a>四、动态组件&amp;插槽&amp;自定义组件</h3><h4 id="1）动态组件"><a href="#1）动态组件" class="headerlink" title="1）动态组件"></a>1）动态组件</h4><h5 id="1-动态组件的使用"><a href="#1-动态组件的使用" class="headerlink" title="1.动态组件的使用"></a>1.动态组件的使用</h5><p>vue提供了一个内置的<code>&lt;component&gt;</code>组件，用来实现组件的动态渲染</p><p><code>is</code>属性里的值表示要渲染的组件的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vue">&lt;component is=&quot;Left&quot;&gt;&lt;/component&gt;<br></code></pre></td></tr></table></figure><h5 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2.keep-alive"></a>2.keep-alive</h5><p>在给<code>is</code>赋值切换组件的时候，会把旧的组件销毁再创建新的组件，如果想要组件不被销毁，则可以使用<code>&lt;keep-alive&gt;</code>标签将<code>&lt;component&gt;</code>包裹，此时切换组件会把旧组件进行缓存，而不是销毁组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>&lt;component is=&quot;Left&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><h5 id="3-keep-alive对应的生命周期函数"><a href="#3-keep-alive对应的生命周期函数" class="headerlink" title="3.keep-alive对应的生命周期函数"></a>3.keep-alive对应的生命周期函数</h5><p>当组件被缓存时，会自动触发组件的<code>deactivated</code>生命周期函数</p><p>当组件被激活时，会自动触发组件的<code>activated</code>生命周期函数</p><p>当组件第一次被创建的时候，既会执行<code>created</code>生命周期，也会执行<code>activated</code>生命周期</p><p>当组件被激活时，只会触发<code>activated</code></p><h5 id="4-keep-live的include与exclude属性"><a href="#4-keep-live的include与exclude属性" class="headerlink" title="4.keep-live的include与exclude属性"></a>4.keep-live的include与exclude属性</h5><p><code>include</code>属性来指定：只有名称匹配的组件会被缓存，多个组件用逗号分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive include=&quot;Left,Right&quot;&gt;<br>&lt;component is=&quot;Left&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p><code>exclude</code>则用来排除不需要被缓存的组件，使用方法与<code>include</code>一致，两个属性不能同时使用</p><h5 id="5-组件的名称"><a href="#5-组件的名称" class="headerlink" title="5.组件的名称"></a>5.组件的名称</h5><p>如果在声明组件的时候，没有为组件指定<code>name</code>名称，则组件的名称默认就是注册时候的名称</p><p>如果在组件内部创建了<code>name</code>属性，组件的名称就是<code>name</code>属性的值（与<code>data</code>平级）</p><blockquote><p>注意，实际开发中最好每一个组件都需要用<code>name</code>属性命名！</p></blockquote><p>组件名称对比：</p><ol><li>组件的“注册名称”的主要应用场景是：以标签的形式，把注册好的组件，渲染和使用到页面结构之中</li><li>组件声明的时候“name”名称的主要应用场景：结合<code>&lt;keep-alive&gt;</code>标签实现组件缓存功能，以及在调试工具中看到组件的<code>name</code>名称</li></ol><h4 id="2）插槽"><a href="#2）插槽" class="headerlink" title="2）插槽"></a>2）插槽</h4><h5 id="1-什么是插槽"><a href="#1-什么是插槽" class="headerlink" title="1.什么是插槽"></a>1.什么是插槽</h5><p>插槽(Slot)是vue为组件的封装者提供的能力，允许开发者在组装组件时，把不确定的、希望由用户指定的部分定义为插槽</p><p><img src="https://s2.loli.net/2022/03/22/MBFeDX8ZCco9QVL.png" alt="image-20220322190615461"></p><h5 id="2-插槽的使用"><a href="#2-插槽的使用" class="headerlink" title="2.插槽的使用"></a>2.插槽的使用</h5><p>vue官方规定，每一个<code>slot</code>插槽都需要有一个<code>name</code>名称</p><p>如果省略了name属性，则有一个默认名称叫做<code>default</code></p><p>默认情况下，在使用组件的时候提供的内容都会被填充到名字为default的插槽之中</p><p>只要<code>slot</code>有自己的名称，它就是一个具名插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Left&gt;<br>&lt;p&gt;在Left组件中创建的p标签&lt;/p&gt;<br>&lt;/Left&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;<br>    &lt;h3&gt;Left组件&lt;/h3&gt;<br>    &lt;hr&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h5 id="3-v-slot"><a href="#3-v-slot" class="headerlink" title="3.v-slot"></a>3.v-slot</h5><p>希望指定内容放到指定的<code>slot</code>里面，则需要把内容包裹在<code>&lt;template&gt;</code>标签里，然后在<code>&lt;template&gt;</code>标签指定<code>v-slot:插槽的名字</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Left&gt;<br>    &lt;template v-slot:default&gt;<br>    &lt;p&gt;在Left组件中创建的p标签&lt;/p&gt;<br>    &lt;/template&gt;<br><br>&lt;/Left&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;template&gt;</code>标签是一个虚拟的标签，只起到包裹的作用，但是不会被渲染为任何实质性的html元素</p><p><code>v-slot</code>的简写形式是<code>#</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Left&gt;<br>    &lt;template #default&gt;<br>    &lt;p&gt;在Left组件中创建的p标签&lt;/p&gt;<br>    &lt;/template&gt;<br><br>&lt;/Left&gt;<br></code></pre></td></tr></table></figure><h5 id="4-后备内容"><a href="#4-后备内容" class="headerlink" title="4.后备内容"></a>4.后备内容</h5><p>封装组件时，可以为预留的<code>&lt;slot&gt;</code>提供后备内容（默认内容），如果组件的使用者没有提供内容则会显示后备内容</p><h5 id="5-作用域插槽"><a href="#5-作用域插槽" class="headerlink" title="5.作用域插槽"></a>5.作用域插槽</h5><p>插槽在设定的时候可以通过设定自定义的属性来给插槽的使用者传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;content&quot; msg=&quot;hello vue.js&quot;&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure><p>使用者在<code>#插槽名</code>后加一个<code>=&quot;变量名&quot;</code>即可接收到这个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template #content=&quot;scope&quot;&gt;&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="3-自定义指令"><a href="#3-自定义指令" class="headerlink" title="3)自定义指令"></a>3)自定义指令</h4><h5 id="1-自定义指令分类"><a href="#1-自定义指令分类" class="headerlink" title="1.自定义指令分类"></a>1.自定义指令分类</h5><ul><li>私有自定义指令（跟组件走）</li><li>全局自定义指令</li></ul><h5 id="2-私有自定义指令"><a href="#2-私有自定义指令" class="headerlink" title="2.私有自定义指令"></a>2.私有自定义指令</h5><p>在每个vue组件中，可以在<code>directives</code>节点下可以声明自定义指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs VUE">&lt;script&gt;<br>export default&#123;<br>    directive: &#123;<br>        color: &#123;<br>            //为绑定到的HTML元素设置红色的文字<br>            bind(el)&#123;<br>                //形参中的el是绑定了此指令的、原生的DOM对象<br>                el.style.color = &#x27;red&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在使用时需要加<code>v-</code>前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h3 v-color&gt;App 根组件&lt;/h3&gt;<br></code></pre></td></tr></table></figure><h5 id="3-binding-value"><a href="#3-binding-value" class="headerlink" title="3.binding.value"></a>3.binding.value</h5><p>在使用自定义指令传值时，可以用<code>binding</code>参数来接收，写在<code>bind(el,binding)</code>的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h3 v-color=&quot;red&quot;&gt;App 根组件&lt;/h3&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    directive: &#123;<br>        color: &#123;<br>            bind(el, binding)&#123;<br>                el.style.color = binding.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="4-update函数"><a href="#4-update函数" class="headerlink" title="4.update函数"></a>4.update函数</h5><p><code>bind</code>函数只会调用一次，当指令第一次绑定到元素时调用，当DOM更新时<code>bind</code>函数不会再次调用，如果需要在DOM更新时指令被执行，则需要用<code>update</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    directive: &#123;<br>        color: &#123;<br>            bind(el, binding)&#123;<br>                el.style.color = binding.value<br>            &#125;,<br>            update(el, binding)&#123;<br>                el.style.color = binding.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="5-函数简写"><a href="#5-函数简写" class="headerlink" title="5.函数简写"></a>5.函数简写</h5><p>如果<code>bind</code>和<code>update</code>函数中的逻辑完全相同，则对象格式可以被简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    directive: &#123;<br>        color()&#123;<br>                el.style.color = binding.value<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="6-全局自定义指令"><a href="#6-全局自定义指令" class="headerlink" title="6.全局自定义指令"></a>6.全局自定义指令</h5><p>全局共享的自定义指令需要通过<code>Vue.directive()</code>在<code>main.js</code>里进行声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//参数1：字符串，表示全局自定义属性的名字</span><br><span class="hljs-comment">//参数2：对象，用来接收指令的参数值</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-params"><span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-keyword">function</span>(el, binding)</span>)&#123;<br>el.<span class="hljs-property">style</span>.<span class="hljs-property">clor</span> = bind<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue学习笔记】三、vue组件与生命周期</title>
    <link href="/blog/2022/03/22/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%E3%80%81vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/blog/2022/03/22/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%E3%80%81vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="三、vue组件与生命周期"><a href="#三、vue组件与生命周期" class="headerlink" title="三、vue组件与生命周期"></a>三、vue组件与生命周期</h3><h4 id="1）vue组件"><a href="#1）vue组件" class="headerlink" title="1）vue组件"></a>1）vue组件</h4><p>vue中规定：组件的后缀名是<code>.vue</code>，<code>App.vue</code>本质上就是一个组件</p><p>每个<code>.vue</code>组件都由3部分组成：</p><ul><li>template -&gt; 组件的模板结构</li><li>script -&gt; 组件的JavaScript行为</li><li>style -&gt; 组件的样式</li></ul><p>注意<code>&lt;script&gt;</code>中必须要写一个默认导出<code>export default&#123;&#125;</code>，这是固定写法</p><p><code>.vue</code>中的data不能像之前一样指向对象，组件中的data必须是一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;h3&gt;这是用户自定义的Test.vue ---- &#123;&#123; username &#125;&#125;&lt;/h3&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>//默认导出，这是固定写法<br>    export default&#123;<br>        //data数据源，不能指向对象<br>       // data:&#123;<br>       //     username: &#x27;zs&#x27;<br>       // &#125;<br>        //必须定义为一个函数<br>        data()&#123;<br>            //这个return出去的&#123;&#125;中可以定义数据<br>            return&#123;<br>                username:&#x27;admin&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&lt;/script&gt;<br><br>&lt;style&gt;<br>    .test-box&#123;<br>        background-color: pink;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><code>methods、watch、computed</code>等写法与之前一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt; <br>export default&#123;<br>        data()&#123;<br>            return&#123;<br>                username:&#x27;admin&#x27;<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            changeName()&#123;<br>                this.username = &#x27;哇哈哈&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt; <br></code></pre></td></tr></table></figure><h4 id="2）组件之间的父子关系"><a href="#2）组件之间的父子关系" class="headerlink" title="2）组件之间的父子关系"></a>2）组件之间的父子关系</h4><p><img src="https://s2.loli.net/2022/03/20/zc8lGJyu7jgnLDA.png" alt="image-20220320192015800"></p><h4 id="3）使用组件的三个步骤"><a href="#3）使用组件的三个步骤" class="headerlink" title="3）使用组件的三个步骤"></a>3）使用组件的三个步骤</h4><ol><li>使用<code>Import</code>语法导入需要的组件</li><li>使用<code>components</code>节点注册组件</li><li>以标签的形式使用刚才注册的组件</li></ol><p><img src="https://s2.loli.net/2022/03/20/1QBDSv5V2iYjpHq.png" alt="image-20220320192416656"></p><p><strong>通过components注册的是私有子组件</strong></p><p>例如：</p><p>在组件A的components节点下，注册了组件F，则F只能在组件A中使用</p><h4 id="4）注册全局组件"><a href="#4）注册全局组件" class="headerlink" title="4）注册全局组件"></a>4）注册全局组件</h4><p>在vue项目的<code>main.js</code>入口文件中，通过<code>Vue.component()</code>方法，可以注册全局组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入需要全局注册的组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Count.vue&#x27;</span><br><br><span class="hljs-comment">//参数1：字符串格式，表示组件的“注册名称”</span><br><span class="hljs-comment">//参数2：需要被全局注册的那个组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyCount&#x27;</span>,<span class="hljs-title class_">Count</span>)<br></code></pre></td></tr></table></figure><h4 id="5）组件的props"><a href="#5）组件的props" class="headerlink" title="5）组件的props"></a>5）组件的props</h4><h5 id="1-创建props自定义属性"><a href="#1-创建props自定义属性" class="headerlink" title="1.创建props自定义属性"></a>1.创建props自定义属性</h5><p>props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大的提高组件的复用性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    props:[&#x27;init&#x27;],<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在使用的注册好的组件标签时以标签属性的形式传参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MyCount</span> <span class="hljs-attr">init</span>=<span class="hljs-string">&quot;9&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyCount</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-结合v-bind使用自定义属性"><a href="#2-结合v-bind使用自定义属性" class="headerlink" title="2.结合v-bind使用自定义属性"></a>2.结合v-bind使用自定义属性</h5><p>加上<code>:</code>之后就加上了<code>v-bind</code>，此时<code>&quot;&quot;</code>里包裹的变成了<code>js</code>语句，单个的9就变成了<code>Number</code>类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;MyCount :init=&quot;9&quot;&gt;&lt;/MyCount&gt;<br></code></pre></td></tr></table></figure><h5 id="3-props是只读的"><a href="#3-props是只读的" class="headerlink" title="3.props是只读的"></a>3.props是只读的</h5><p>vue规定：组件中封装的自定义属性是只读的，程序员不能直接修改props的值，否则会直接报错</p><p><img src="https://s2.loli.net/2022/03/20/17t2ElsoRu3Hh9k.png" alt="image-20220320200807892"></p><h5 id="4-转接props值"><a href="#4-转接props值" class="headerlink" title="4.转接props值"></a>4.转接props值</h5><p>如果想要修改props中属性的值，应该让data中的属性来转接这个值</p><p>把<code>init</code>赋值给<code>count</code>，直接让<code>count: this.init</code>即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    props:[&#x27;init&#x27;],<br>    data()&#123;<br>        return&#123;<br>            count: this.init<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="5-props的默认值"><a href="#5-props的默认值" class="headerlink" title="5.props的默认值"></a>5.props的默认值</h5><p>在声明自定义属性时，可以通过default来定义属性的默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    props:&#123;<br>        init:&#123;<br>            //用default属性定义属性的默认值<br>            default: 0<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="6-props的type属性"><a href="#6-props的type属性" class="headerlink" title="6.props的type属性"></a>6.props的type属性</h5><p>在声明自定义属性时，可以通过type来定义属性的值类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    props:&#123;<br>        init:&#123;<br>            default: 0,<br>            //init值的类型必须是Number数字<br>            type: Number<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="7-props的required必填项"><a href="#7-props的required必填项" class="headerlink" title="7.props的required必填项"></a>7.props的required必填项</h5><p><code>required</code>属性为true表示该props属性为必填项，如果不传就会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>    props:&#123;<br>        init:&#123;<br>            default: 0,<br>            type: Number,<br>            //必填项校验<br>            required: true,<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="6）组件之间的样式冲突问题"><a href="#6）组件之间的样式冲突问题" class="headerlink" title="6）组件之间的样式冲突问题"></a>6）组件之间的样式冲突问题</h4><h5 id="1-冲突的原因"><a href="#1-冲突的原因" class="headerlink" title="1.冲突的原因"></a>1.冲突的原因</h5><p>默认情况下，写在<code>.vue</code>中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题</p><p>样式冲突的根本原因：</p><ol><li>单页面程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</li><li>每个组件中的样式，都会影响整个index.html页面中的DOM元素</li></ol><h5 id="2-冲突的解决方法"><a href="#2-冲突的解决方法" class="headerlink" title="2.冲突的解决方法"></a>2.冲突的解决方法</h5><p>在<code>&lt;style&gt;</code>标签中加上<code>scoped</code>属性即可解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&quot;less&quot; scoped&gt;<br>    .test-box&#123;<br>        background-color: pink;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>原理是在组件中的每个标签里加上一个不同的自定义属性<code>data-v-xxx</code>，通过自定义属性选择器<code>[data-v-xxx]</code>选择到这个属性</p><h5 id="3-使用deep修改子组件中的样式"><a href="#3-使用deep修改子组件中的样式" class="headerlink" title="3.使用deep修改子组件中的样式"></a>3.使用<code>deep</code>修改子组件中的样式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style lang=&quot;less&quot; scoped&gt;<br>    .test-box&#123;<br>        background-color: pink;<br>    &#125;<br>    /deep/ h5&#123;<br>        color: pink;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这样操作会把<code>h5[data-v-xxx]</code>变为<code>[data-v-xxx] h5</code>，变成了一个后代选择器</p><p>当使用第三方组件库的时候，如果有修改组件默认样式的需求，需要用到<code>/deep/</code>（因为不能直接修改组件库的源码）</p><h4 id="7）vue组件的实例对象"><a href="#7）vue组件的实例对象" class="headerlink" title="7）vue组件的实例对象"></a>7）vue组件的实例对象</h4><p>创建点<code>.vue</code>组件相当于创建了一个构造函数，在以标签的形式使用的时候就相当于<code>new</code>了一个组件实例，每一个组件就相当于一个<code>Vue</code>实例</p><h4 id="8）生命周期"><a href="#8）生命周期" class="headerlink" title="8）生命周期"></a>8）生命周期</h4><h5 id="1-生命周期-amp-生命周期函数"><a href="#1-生命周期-amp-生命周期函数" class="headerlink" title="1.生命周期&amp;生命周期函数"></a>1.生命周期&amp;生命周期函数</h5><p>生命周期（Life Cycle）是指一个组件从<strong>创建 -&gt; 运行 -&gt; 销毁</strong>的整个阶段，强调的是一个时间段</p><p>生命周期函数：是由vue框架提供的内置函数，会伴随组件的生命周期，自动按次序执行</p><p>生命周期函数与<code>props/data/methods</code>等同级，以函数的形式创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default&#123;<br>        data:&#123;<br>        &#125;,<br>        beforeCreated()&#123; //创建了beforeCreated生命周期函数<br><br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="2-组件生命周期函数的分类"><a href="#2-组件生命周期函数的分类" class="headerlink" title="2.组件生命周期函数的分类"></a>2.组件生命周期函数的分类</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220321145908355.png" alt="image-20220321145908355"></p><p>按照这个顺序依次执行函数其中<code>create</code>代表创建，<code>mount</code>代表渲染到页面上，<code>update</code>代表组件更新，<code>Destroy</code>代表销毁</p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期" style="zoom: 25%;" /><h5 id="3-beforeCreate和created的特点"><a href="#3-beforeCreate和created的特点" class="headerlink" title="3.beforeCreate和created的特点"></a>3.beforeCreate和created的特点</h5><img src="https://s2.loli.net/2022/03/21/UZ43tajgGBD6qfE.png" alt="image-20220321150857622" style="zoom:50%;" /><p>在<code>beforeCreate</code>阶段，组件的<code>props/data/methods</code>都处于不可用的状态，这个生命周期不重要</p><p>在<code>created</code>阶段，组件的<code>props/data/methods</code>已创建好可以使用，但是模板结构尚未生成</p><blockquote><p>注意：在<code>created</code>阶段，可以使用Ajax请求数据来初始化参数，非常常用！</p></blockquote><h5 id="4-beforeMount和mounted"><a href="#4-beforeMount和mounted" class="headerlink" title="4.beforeMount和mounted"></a>4.beforeMount和mounted</h5><img src="https://s2.loli.net/2022/03/21/q3ZlOyjCpG4TLNB.png" alt="image-20220321152520477" style="zoom:50%;" /><p>在<code>beforeMount</code>之前，先寻找要要生成结构的区域（’#app’），然后根据数据和模板在这个区域中生成<code>html</code>结构，这个阶段同样可以发起Ajax请求，但是在<code>created</code>阶段发起更好，所以这个阶段也不重要</p><img src="https://s2.loli.net/2022/03/21/VSruEH2njA4DqPB.png" alt="image-20220321152923600" style="zoom:50%;" /><p>如果要操作当前实例的DOM，最早可以在<code>mounted</code>阶段操作</p><h5 id="5-beforeUpdate和updated"><a href="#5-beforeUpdate和updated" class="headerlink" title="5.beforeUpdate和updated"></a>5.beforeUpdate和updated</h5><img src="https://s2.loli.net/2022/03/21/lO2ZGYEXrCbWVdp.png" alt="image-20220321153230031" style="zoom:50%;" /><p>在数据发生变化之后会执行<code>beforeUpdate</code>阶段，然后再将更新的数据渲染到组件的DOM结构里，这个阶段会在<strong>页面刚打开的时候触发一次</strong></p><p>更新数据渲染完毕后触发<code>updated</code></p><p>当数据发生变化之后，为了能够操作到最新的DOM结构，代码必须写在<code>created</code>阶段</p><h5 id="6-beforeDestroy和destroyed"><a href="#6-beforeDestroy和destroyed" class="headerlink" title="6.beforeDestroy和destroyed"></a>6.beforeDestroy和destroyed</h5><p>这两个阶段不常用</p><p>使用<code>v-if</code>可以实现组件的销毁</p><img src="https://s2.loli.net/2022/03/21/JtcM1ha5l2NEk8q.png" alt="image-20220321153908600" style="zoom:50%;" /><h4 id="9）组件之间的数据共享"><a href="#9）组件之间的数据共享" class="headerlink" title="9）组件之间的数据共享"></a>9）组件之间的数据共享</h4><h5 id="1-组件之间的关系"><a href="#1-组件之间的关系" class="headerlink" title="1.组件之间的关系"></a>1.组件之间的关系</h5><p>在项目开发中，组件之间最常见的关系分为如下两种：</p><ul><li>父子关系</li><li>兄弟关系</li></ul><p>如果两个组件离得比较远，则当作兄弟关系处理（即使是后代）</p><h5 id="2-父组件向子组件传递数据"><a href="#2-父组件向子组件传递数据" class="headerlink" title="2.父组件向子组件传递数据"></a>2.父组件向子组件传递数据</h5><p>使用<strong>自定义属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">//父组件<br>&lt;Son :msg=&quot;message&quot; :user=&quot;userinfo&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>data()&#123;<br>return&#123;<br>message: &#x27;hello vue.js&#x27;,<br>userinfo: &#123; name: &#x27;zs&#x27;, age: 20&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">//父组件<br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;h5&gt;Son组件&lt;/h5&gt;<br>        &lt;p&gt;父组件传递过来的msg指是：&#123;&#123; msg &#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;父组件传递过来的user指是：&#123;&#123; user &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>props: [&#x27;msg&#x27;, &#x27;user&#x27;]<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>传递复杂对象是传递一个引用，使用<code>user.name</code>可以直接修改到父组件中的<code>user.name</code>，一般不要这么操作，而应该去设定一个新变量来接收</p><h5 id="3-子组件向父组件传递数据"><a href="#3-子组件向父组件传递数据" class="headerlink" title="3.子组件向父组件传递数据"></a>3.子组件向父组件传递数据</h5><ol><li>先定义一个变量来接收子组件传递过来的值</li><li>子组件向父组件共享数据使用自定义事件</li></ol><p><code>$emit(事件，参数)</code>代表触发一个事件，父组件中按照触发事件同样的方法去接收这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">//子组件<br><br>&lt;script&gt;<br>export default &#123;<br>    data()&#123; return&#123;count: 0&#125;&#125;,<br>    methods: &#123;<br>        add()&#123;<br>            this.count++;<br>            //修改数据时，通过$emit()触发自定义事件<br>            this.$emit(&#x27;numchange&#x27;,this.count);<br>        &#125;,<br>    &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">//父组件<br>&lt;Son @numchange=&quot;getNewCount&quot;&gt;&lt;/Son&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    data()&#123; return&#123;countFromSon: 0&#125;&#125;,<br>    methods: &#123;<br>        getNewCount(val)&#123;<br>            this.countFromSon = val<br>        &#125;,<br>    &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="4-兄弟组件之间的数据共享"><a href="#4-兄弟组件之间的数据共享" class="headerlink" title="4.兄弟组件之间的数据共享"></a>4.兄弟组件之间的数据共享</h5><p>在vue2.x中，兄弟组件之间数据共享的方案是<code>EventBus</code></p><p><img src="https://s2.loli.net/2022/03/21/ZxLFH9AS7nVJqO2.png" alt="image-20220321162602991"></p><ul><li>创建<code>eventBus.js</code>模块，并向外共享一个Vue的实例对象</li><li>在数据发送方，调用<code>bus.$emit(&#39;事件名称&#39;, 要发送的数据)</code>来发送数据</li><li>在数据接收方，调用<code>bus.$on(&#39;事件名称&#39;, 事件处理函数)</code>来接收数据</li></ul><p>接收方写在<code>created</code>阶段中，是一个固定写法</p><h4 id="10）ref引用"><a href="#10）ref引用" class="headerlink" title="10）ref引用"></a>10）ref引用</h4><h5 id="1-ref操作DOM"><a href="#1-ref操作DOM" class="headerlink" title="1.ref操作DOM"></a>1.ref操作DOM</h5><ul><li>在需要操作的标签上命名一个属性<code>ref=&quot;xxx&quot;</code></li><li>通过<code>this.$refs.xxx</code>来操作DOM</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myh1&quot;</span>&gt;</span>一个标签<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">showThis</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myh1</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;red&quot;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-ref操作组件"><a href="#2-ref操作组件" class="headerlink" title="2.ref操作组件"></a>2.ref操作组件</h5><p>ref除了可以操作DOM，也可以用来操作组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;Left ref=&quot;comLeft&quot;&gt;&lt;/Left&gt; //给子组件绑定了ref名称<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>methods:&#123;<br>        onReset()&#123;<br>            this.$refs.comLeft.resetCount() //可以用refs来调用Left组件里的resetCount()方法<br>            this.$refs.comLeft.count = 0 //也可以直接操作值<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="3-this-nextTick"><a href="#3-this-nextTick" class="headerlink" title="3.this.$nextTick"></a>3.this.$nextTick</h5><p>如果想把代码的执行延后到页面重新渲染完毕之后，需要用到<code>this.$nextTick(callback)</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>methods:&#123;<br>        showInput()&#123;<br>            this.inputVisible = true<br>            //此时把布尔值改变了，但是因为生命周期，页面还没有来得及渲染，下面的语句找不到这个文本框<br>            console.log(this.$refs.iptRef)<br>            //使用$nextTick方法执行就不会报错<br>            this.$nextTick(() =&gt; &#123;<br>                console.log(this.$refs.iptRef)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue学习笔记】二、vue基础入门</title>
    <link href="/blog/2022/03/20/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/blog/2022/03/20/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="二、vue基础入门"><a href="#二、vue基础入门" class="headerlink" title="二、vue基础入门"></a>二、vue基础入门</h3><h4 id="1）vue的特性"><a href="#1）vue的特性" class="headerlink" title="1）vue的特性"></a>1）vue的特性</h4><ul><li>数据驱动视图</li><li>双向数据绑定</li></ul><p><strong>数据驱动视图</strong></p><p>在使用了vue的页面中，vue会<strong>监听数据的变化</strong>，从而自动重新渲染页面的结构，示意图如下：</p><p><img src="https://s2.loli.net/2022/03/20/dpCgbhlPXoWrYJs.png" alt="image-20220320123228267"></p><p>注意：数据驱动视图是单向的数据绑定。</p><p><strong>双向数据绑定</strong></p><p>在网页中，form表单负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong></p><p>在vue中，在填写表单时，双向数据绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中</p><p><img src="https://s2.loli.net/2022/03/20/ex3WudHXcsmo1CJ.png" alt="image-20220320123736001"></p><p>好处：不用手动操作DOM来获取表单元素最新的值</p><h4 id="2）MVVM"><a href="#2）MVVM" class="headerlink" title="2）MVVM"></a>2）MVVM</h4><p>MVVM是vue实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理，MVVM指的是Model、View和ViewModel，它把每个HTML页面都拆分成了三个部分</p><p><img src="https://s2.loli.net/2022/03/20/AWcbtsCI3rNTYqg.png" alt="image-20220320124040646"></p><p>ViewModel作为MVVM的核心，是它把当前页面的**数据源(Model)<strong>和</strong>页面的结构(View)**连接在了一起</p><p><img src="https://s2.loli.net/2022/03/20/7togxUbcT6i9nYG.png" alt="image-20220320124206739"></p><h4 id="3）vue的基本使用"><a href="#3）vue的基本使用" class="headerlink" title="3）vue的基本使用"></a>3）vue的基本使用</h4><h5 id="1-基本使用步骤"><a href="#1-基本使用步骤" class="headerlink" title="1.基本使用步骤"></a>1.基本使用步骤</h5><ol><li>导入vue.js的script脚本文件</li><li>在页面声明一个将要被vue所控制的DOM区域</li><li>创建vm实例对象（vue实例对象）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 希望vue能够控制下面的这个div，帮我们把数据填充到div内部 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 固定语法双花括号表示要渲染的数据 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>&#123;&#123;  username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.导入Vue的库文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lib/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.创建Vue实例 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//创建vue的实例对象</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//el属性是固定的写法，表示当前vm实例要控制页面上的哪个区域，接收的值是一个选择器</span></span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-comment">//data对象就是要渲染到页面上的数据</span></span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4）Vue的指令与过滤器"><a href="#4）Vue的指令与过滤器" class="headerlink" title="4）Vue的指令与过滤器"></a>4）Vue的指令与过滤器</h4><h6 id="1-指令的概念"><a href="#1-指令的概念" class="headerlink" title="1.指令的概念"></a>1.指令的概念</h6><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构</p><p>指令分为6大类：</p><ul><li>内容渲染指令</li><li>属性绑定指令</li><li>事件绑定指令</li><li>双向绑定指令</li><li>条件渲染指令</li><li>列表渲染指令</li></ul><h6 id="2-内容渲染指令"><a href="#2-内容渲染指令" class="headerlink" title="2.内容渲染指令"></a>2.内容渲染指令</h6><p>内容渲染指令用来辅助开发者渲染DOM元素的文本内容，常用的内容渲染指令有如下3个：</p><ul><li><code>v-text</code></li><li><code>&#123;&#123;&#125;&#125;`- `v-html`**`v-text`**用法示例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 把username的值渲染到p标签中 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 把gender的值渲染到p标签中，覆盖掉“性别” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>`v-text`指令的缺点：会覆盖掉元素内部的内容**`&#123;&#123; &#125;&#125;</code>语法**</li></ul><p>这种语法的专业名称是插值表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用&#123;&#123;&#125;&#125;插值表达式，将对应的值渲染到元素的内容节点中 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 同时奥六元素自身的默认值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>性别：&#123;&#123;gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插值表达式在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容</p><p><strong><code>v-html</code>指令</strong></p><p><code>v-text</code>指令和差值表达式只能渲染纯文本内容，如果要把包含html标签的字符串渲染为页面HTML元素，需要用到<code>v-html</code>这个指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">info</span>:<span class="hljs-string">&#x27;&lt;h4 style=&quot;color:red;font-weight:bold&quot;&gt;信息&lt;/h4&gt;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="3-属性绑定指令"><a href="#3-属性绑定指令" class="headerlink" title="3.属性绑定指令"></a>3.属性绑定指令</h6><p>插值表达式不能用在属性节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>            <span class="hljs-attr">data</span>: &#123;<br>                <span class="hljs-attr">tips</span>:<span class="hljs-string">&#x27;请输入用户名&#x27;</span><br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 错误示范，会报错 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;&#123;&#123;tips&#125;&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要为元素的属性动态绑定属性值，则需要用到<code>v-bind</code>属性绑定指令</p><p>用法：<code>v-bind:需要绑定的属性=&quot;属性&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:placeholder</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>vue规定，<code>v-bind</code>可以简写为:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-使用Javascript表达式"><a href="#4-使用Javascript表达式" class="headerlink" title="4.使用Javascript表达式"></a>4.使用Javascript表达式</h6><p>在vue提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持javascript表达式的运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; number + 1 &#125;&#125;<br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27;&#125;&#125;<br><br>&#123;&#123; message.split(&#x27;&#x27;&#125;.reverse().join(&#x27;&#x27;) &#125;<br><br> &lt;div :id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h6 id="5-事件绑定指令"><a href="#5-事件绑定指令" class="headerlink" title="5.事件绑定指令"></a>5.事件绑定指令</h6><p><strong>v-on</strong></p><p>vue提供了<code>v-on</code>事件绑定指令，用来辅助成需要为DOM元素绑定事件监听</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>事件处理函数定义在vue构造函数的<code>methods</code>里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//完整写法</span><br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-attr">add</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//简写写法，去掉冒号和function</span><br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>this</code>访问数据源中的数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绑定事件并传参</strong></p><p>为了让方法更加通用，可以设定参数，在绑定事件的同时用()就可以直接传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">n</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add(2)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>v-on指令可以被简写为<code>@</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(2)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：原生DOM对象有<code>onclick、oninput、onkeyup</code>等原生事件，替换为vue的事件绑定形式后，分别为<code>v-on:click、v-on:input、v-on:keyup</code>，直接把原生的on替换为<code>@</code>即可</p><h6 id="6-事件绑定-event"><a href="#6-事件绑定-event" class="headerlink" title="6.事件绑定 $event"></a>6.事件绑定 $event</h6><p>使用v-on绑定事件的时候，不传参也会默认传递一个事件对象event，可以根据event来操作DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">e</span>) &#123;<br>        e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果传递了参数，事件对象会被覆盖掉，此时可以使用vue提供的内置变量，名字叫做<code>$event</code>，它就是原生DOM的事件对象e</p><p>在绑定事件时把<code>$event</code>作为参数传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(2, $event)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">n,e</span>) &#123;<br>        e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="7-事件修饰符"><a href="#7-事件修饰符" class="headerlink" title="7.事件修饰符"></a>7.事件修饰符</h6><p>原生阻止默认行为需要操作事件对象<code>e.preventDefault()</code>，在vue中，可以在绑定v-on时增加<code>.prevent</code>，即可完成阻止默认事件的操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>跳转到百度首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常用的5个事件修饰符如下</p><table><thead><tr><th>事件修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.prevent</td><td>阻止默认行为（例如：阻止a链接的跳转、阻止表单的提交等） = e.preventDefault()</td></tr><tr><td>.stop</td><td>阻止事件冒泡 = e.stopPropagation()</td></tr><tr><td>.capture</td><td>以捕获模式触发当前的事件处理函数</td></tr><tr><td>.once</td><td>绑定的事件只触发1次</td></tr><tr><td>.self</td><td>只有在event.targe是当前元素自身时触发事件处理函数</td></tr></tbody></table><h6 id="8-按键修饰符"><a href="#8-按键修饰符" class="headerlink" title="8.按键修饰符"></a>8.按键修饰符</h6><p>在监听键盘事件时，我们经常需要判断详细的按键，此时可以为键盘相关的事件添加按键修饰符，例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 只有在&#x27;key&#x27;是&#x27;Enter‘时调用&#x27;vm.submit()&#x27; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 只有在&#x27;key&#x27;是&#x27;Esc‘时调用&#x27;vm.cleanInput()&#x27; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.esc</span>=<span class="hljs-string">&quot;cleanInput&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="9-双向绑定指令v-model"><a href="#9-双向绑定指令v-model" class="headerlink" title="9.双向绑定指令v-model"></a>9.双向绑定指令<code>v-model</code></h6><p>vue提供了<code>v-model</code>双向数据绑定指令，用来辅助开发者在不操作DOM的前提下，快速获取表单的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名是：&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>选中的省份是：&#123;&#123; province &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;province&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>只有表单元素才可使用<code>v-model</code></p><ol><li>input输入框<ul><li>type=”radio”</li><li>type=”checkboc”</li><li>type=”xxxx”</li></ul></li><li>textarea</li><li>select</li></ol><h6 id="10-v-model的修饰符"><a href="#10-v-model的修饰符" class="headerlink" title="10.v-model的修饰符"></a>10.<code>v-model</code>的修饰符</h6><p>为了对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符，分别是：</p><table><thead><tr><th>修饰符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>.number</td><td>自动将用户的输入值转为数值类型</td><td><input v-model.number="age" /></td></tr><tr><td>.trim</td><td>自动过滤用户输入的首尾空白字符</td><td><input v-model.trim="msg" /></td></tr><tr><td>.lazy</td><td>在“change”时而非”input”时更新</td><td><input v-model.lazy="msg" /></td></tr></tbody></table><h6 id="11-条件渲染指令"><a href="#11-条件渲染指令" class="headerlink" title="11.条件渲染指令"></a>11.条件渲染指令</h6><p>条件渲染指令用来辅助开发者按需控制DOM的显示与因此，条件渲染指令有如下两个，分别是：</p><ul><li>v-if</li><li>v-show</li></ul><p>示例用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;networkState == 200&quot;</span>&gt;</span> 请求成功 --- 被v-if控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;networkState === 200&quot;</span>&gt;</span>请求成功 --- 被v-show控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>区别在于隐藏元素的方式，<code>v-if</code>是动态地移除或创建元素，而<code>v-show</code>是修改<code>style=&#39;display:none;&#39;</code>，如果需要频繁地修改，<code>v-show</code>的性能更好，如果默认不需要被展示，而且后期也很可能不需要被展示出来<code>v-if</code>的性能会更好</p><p>实际开发中，绝大多数情况不需要考虑性能问题，直接使用<code>v-if</code>就好了</p><h6 id="11-v-if配套的指令"><a href="#11-v-if配套的指令" class="headerlink" title="11.v-if配套的指令"></a>11.<code>v-if</code>配套的指令</h6><p><strong>v-else-if</strong></p><p><code>v-else-if</code>指令，顾名思义，充当v-if的“<code>else-if块</code>“，可以连续使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>差<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：<code>v-else-if</code>指令必须配合<code>v-if</code>指令一起使用，否则它将不会被识别</p><h6 id="12-列表渲染指令"><a href="#12-列表渲染指令" class="headerlink" title="12.列表渲染指令"></a>12.列表渲染指令</h6><p>vue提供了<code>v-for</code>列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。<code>v-for</code>指令需要使用<code>item in items</code>形式的特殊语法，其中：</p><ul><li><code>items</code>是待循环的数组</li><li><code>item</code>是被循环的每一项</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">list</span>:[<br>        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ls&#x27;</span> &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span>姓名是：&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><code>v-for</code>中的索引</strong></p><p>v-for指令还支持一个可选的第二个参数，即当前项的索引，语法格式为<code>(item, index) in times</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span>&gt;</span>索引是：&#123;&#123; index &#125;&#125;姓名是：&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>官方建议：只要用到了<code>v-for</code>指令 ，那么一定要绑定一个<code>:key</code>属性，而且，尽量把<code>id</code>作为<code>key</code>的值</p><p>官方对<code>key</code>的值类型，是有要求的：字符串或数字类型</p><p><code>key</code>值是千万不能重复的，否则会报错</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>            索引是：&#123;&#123; index &#125;&#125;姓名是：&#123;&#123;item.name&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="13-过滤器"><a href="#13-过滤器" class="headerlink" title="13.过滤器"></a>13.过滤器</h6><blockquote><p>过滤器在vue3已经被删除，只需了解即可！</p><p>在vue3中，官方建议使用计算属性或方法代替被剔除的过滤器功能</p></blockquote><p>过滤器(Filters)是vue为开发者提供的功能，常用于文本的格式化，过滤器可以用在两个地方：插值表达式和<code>v-bind</code>属性绑定</p><p>其中<code>|</code>叫做管道符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--调用了capitalize过滤器，来对message的首字母大写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | capitalize&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--调用了formatId过滤器，来对rawID操作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>过滤器函数，必须被定义到filters节点之下</p><p>过滤器本质上是函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">filters</span>:&#123;<br>    <span class="hljs-comment">//过滤器函数形参中的val永远都是管道符前面的值</span><br>    <span class="hljs-title function_">capitalize</span>(<span class="hljs-params">val</span>)&#123;<br>        <span class="hljs-comment">//过滤器中，一定要有返回值</span><br>        <span class="hljs-keyword">const</span> first = val.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>()<br>        <span class="hljs-comment">//slice方法截取字符串，从指定索引往后截取</span><br>        <span class="hljs-keyword">const</span> other = val.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> first + other;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>私有过滤器和全局过滤器</strong></p><p>定义在<code>filters</code>里的是私有过滤器，只能在当前vue构造函数里<code>el:</code>指定的代码块中有效</p><p>在如果需要在多个vue实例之间共享过滤器，则可以按照如下格式定义全局过滤器：</p><p><img src="https://s2.loli.net/2022/03/20/TcbpE8x2Ce5OvsN.png" alt="image-20220320161648974"></p><p><strong>过滤器可以串联使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | filter1 | filter2 | filter3&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>过滤器本质是js函数，因此可以接收参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p&gt;&#123;&#123; message | <span class="hljs-title function_">filter1</span>(arg1,arg2)&#125;&#125;&lt;/p&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;filterA&#x27;</span>,(msg,arg1,arg2)) =&gt; &#123; <span class="hljs-comment">//第一个位置定死了，一定是管道符前面的</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）侦听器"><a href="#5）侦听器" class="headerlink" title="5）侦听器"></a>5）侦听器</h4><h5 id="1-什么是watch侦听器"><a href="#1-什么是watch侦听器" class="headerlink" title="1.什么是watch侦听器"></a>1.什么是watch侦听器</h5><p>watch侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作</p><p>侦听器本质就是函数，要监听哪个数据的变化，就把数据名作为方法名即可</p><p>语法结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>    <span class="hljs-attr">watch</span>: &#123;<br>        <span class="hljs-comment">//监听username值的变化</span><br>        <span class="hljs-comment">//newVal是“变化后的新值”，oldVal是“变化之前的旧值”</span><br>        <span class="hljs-title function_">username</span>(<span class="hljs-params">newVal, oldVal</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal,oldVal)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="2-侦听器的格式"><a href="#2-侦听器的格式" class="headerlink" title="2.侦听器的格式"></a>2.侦听器的格式</h5><ol><li>方法格式的侦听器<ul><li>缺点1：无法在刚进入页面的时候自动触发</li><li>缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器</li></ul></li><li>对象格式的侦听器<ul><li>好处1：可以通过<code>immediate</code>选项，让侦听器自动触发</li><li>好处2：可以通过<code>deep</code>选项，让侦听器深度监听对象中每个属性的变化</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-comment">//定义对象格式的侦听器</span><br>    <span class="hljs-attr">username</span>:&#123;<br>        <span class="hljs-comment">//侦听器的处理函数</span><br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal,oldVal</span>)&#123;<br>            <br>        &#125;,<br>        <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//打开页面立即触发一次</span><br>        <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//开启深度监听，对象中任何一个属性变化都会触发“对象的侦听器”</span><br>            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要实现需求，先使用简单的方法，解决不了再考虑复杂的方法，优先使用方法格式的侦听器</p><p><strong>侦听对象的属性的变化</strong></p><p>如果要侦听对象里面的属性，必须外层包裹一层单引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-string">&#x27;info.username&#x27;</span>(newVal)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-案例：判断用户名是否被占用"><a href="#3-案例：判断用户名是否被占用" class="headerlink" title="3.案例：判断用户名是否被占用"></a>3.案例：判断用户名是否被占用</h5><p>监听username值的变化，并使用axios发起Ajax请求，检测当前输入的用户名是否可用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-comment">//监听username值的变化</span><br>    <span class="hljs-comment">//newVal是“变化后的新值”，oldVal是“变化之前的旧值”</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">newVal</span>)&#123;<br>        <span class="hljs-keyword">if</span>(newVal === <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">//使用axios发起请求，判断用户名是否可用</span><br>        cosnt&#123; <span class="hljs-attr">data</span>: res &#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://www.escook.cn/api/finduser/&#x27;</span> + newVal)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="6）计算属性"><a href="#6）计算属性" class="headerlink" title="6）计算属性"></a>6）计算属性</h4><p>计算属性指的是通过一系列运算之后，最终得到一个属性值</p><p>这个动态计算出来的属性值可以被模板结构或methods方法使用，示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-title function_">rgb</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.r&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.g&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.b&#125;</span>)`</span>&#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rgb</span>)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>特点：</p><ol><li>定义的时候要定义为方法</li><li>当作普通的属性使用即可</li></ol><p>好处：</p><ol><li>实现了代码的复用</li><li>只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值</li></ol><h4 id="7）单页面程序"><a href="#7）单页面程序" class="headerlink" title="7）单页面程序"></a>7）单页面程序</h4><h5 id="1-什么是单页面程序"><a href="#1-什么是单页面程序" class="headerlink" title="1.什么是单页面程序"></a>1.什么是单页面程序</h5><p>单页面程序（Single Page Application)简称SPA，顾名思义，指的是一个Web网站中只有唯一的一个HTML页面，所有的功能与交互都在这唯一的一个页面内完成</p><h5 id="2-什么vue-cli"><a href="#2-什么vue-cli" class="headerlink" title="2.什么vue-cli"></a>2.什么vue-cli</h5><p>vue-cli是Vue.js开发的标准工具，它简化了基于webpack创建工程化的Vue项目的过程</p><p>vue-cli是npm上的一个全局包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br></code></pre></td></tr></table></figure><p>基于vue-cli快速生成工程化的Vue项目：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">vue <span class="hljs-keyword">create</span> 项目的名称<br></code></pre></td></tr></table></figure><h5 id="3-vue项目中src目录的构成"><a href="#3-vue项目中src目录的构成" class="headerlink" title="3.vue项目中src目录的构成"></a>3.vue项目中src目录的构成</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">assest 文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源<br>components 文件夹：程序员封装的、可复用的组件<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span> 是项目的入口文件，整个项目的运行，要先执行<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span><br>App.vue是项目的根组件<br></code></pre></td></tr></table></figure><h5 id="4-vue项目的运行流程"><a href="#4-vue项目的运行流程" class="headerlink" title="4.vue项目的运行流程"></a>4.vue项目的运行流程</h5><p>在工程化的项目中，vue要做的事情非常简单：通过<code>main.js</code>把<code>App.vue</code>渲染到<code>index.html</code>里去</p><p>其中</p><ul><li><code>App.vue</code>用来编写待渲染的模板结构</li><li><code>index.html</code>中需要预留一个el区域</li><li><code>main.js</code>把App.vue渲染到了index.html所预留的区域中</li></ul><p><code>main.js</code>中的<code>.$mount(#app)</code>与el属性是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>) <span class="hljs-comment">//等于el: &#x27;#app&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue学习笔记】一、前端工程化与Webpack</title>
    <link href="/blog/2022/03/20/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/"/>
    <url>/blog/2022/03/20/%E3%80%90Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/</url>
    
    <content type="html"><![CDATA[<h3 id="一、前端工程化与Webpack"><a href="#一、前端工程化与Webpack" class="headerlink" title="一、前端工程化与Webpack"></a>一、前端工程化与Webpack</h3><p><strong>注意：该部分内容仅需了解原理，不需要特别记忆</strong></p><h4 id="1-前端工程化"><a href="#1-前端工程化" class="headerlink" title="1)前端工程化"></a>1)前端工程化</h4><ul><li>模块化（js的模块化、css的模块化、资源的模块化）</li><li>组件化（复用现有的UI结构、样式、行为）</li><li>规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、GIt分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><h4 id="2）webpack"><a href="#2）webpack" class="headerlink" title="2）webpack"></a>2）webpack</h4><p>概念：webpack是前端项目工程化的具体解决方案</p><p>主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端JavaScript的兼容性、性能优化等强大的功能</p><p>插件在<a href="https://npmjs.com中查阅文档/">https://npmjs.com中查阅文档</a></p><h4 id="3）webpack的基本使用"><a href="#3）webpack的基本使用" class="headerlink" title="3）webpack的基本使用"></a>3）webpack的基本使用</h4><h5 id="1-创建列表隔行变色项目"><a href="#1-创建列表隔行变色项目" class="headerlink" title="1.创建列表隔行变色项目"></a>1.创建列表隔行变色项目</h5><p><img src="https://s2.loli.net/2022/03/19/uf6R3jODmHACTkK.png" alt="image-20220319182041038"></p><ul><li><p>npm install xxx <strong>-S</strong>命令把包记录到dependencies里（上线要用）（是–save的简写）</p></li><li><p>npm install xxx <strong>-D</strong>命令把包记录到devDependencies里（仅开发用）(是–save-dev的简写)</p></li></ul><h5 id="2-在项目中配置webpack"><a href="#2-在项目中配置webpack" class="headerlink" title="2.在项目中配置webpack"></a>2.在项目中配置webpack</h5><ol><li>在项目根目录中，创建名为webpack.config.js的webpack配置文件，并初始化如下的基本配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span> <span class="hljs-comment">//mode用来指定构建模式，可选值有development和production</span><br>    <span class="hljs-comment">//如果是production，则会进行代码压缩</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在package.json的scripts节点下，新增dev脚本如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span> <span class="hljs-comment">//script节点下的脚本，可以通过npm run执行，例如npm run dev</span><br>&#125;<br></code></pre></td></tr></table></figure><p>dev可以任意命名，是npm run xxx的名字</p><p>3.在终端中运行npm run dev执行打包，然后会在dist文件夹下生成main.js，在Index.html中导入该js即可</p><p><img src="https://s2.loli.net/2022/03/19/Xytj5COibKLUYV8.png" alt="image-20220319184623642"></p><h5 id="3-指定webpack的entry和output"><a href="#3-指定webpack的entry和output" class="headerlink" title="3.指定webpack的entry和output"></a>3.指定webpack的entry和output</h5><p>在webpack 4.x和5.x的版本中，有如下的默认约定：</p><p>①默认的打包入口文件为<strong>src -&gt; index.js</strong></p><p>②默认的输出文件路径为<strong>dist -&gt; main.js</strong></p><p>在webpack.config.js配置文件中，通过entry节点指定打包的入口，通过output节点指定打包的出口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>) <span class="hljs-comment">//导入node.js中专门操作路径的模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./src/index.js&#x27;</span>), <span class="hljs-comment">//打包入口文件的路径</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>). <span class="hljs-comment">//输出文件的存放路径</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span> <span class="hljs-comment">//输出文件的名称</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-webpack中的插件"><a href="#4-webpack中的插件" class="headerlink" title="4.webpack中的插件"></a>4.webpack中的插件</h5><p>最常用的webpack插件有如下两个：</p><p>①webpack-dev-server</p><ul><li>类似于node.js中的nodemon工具</li><li>每当修改了源代码，webpack会自动进行项目的打包和构建</li></ul><p>②html-webpack-plugin</p><ul><li>webpack中的HTML插件（类似于一个模板引擎插件）</li><li>可以通过此插件自定制index.html页面的内容</li></ul><h6 id="①配置webpack-dev-server"><a href="#①配置webpack-dev-server" class="headerlink" title="①配置webpack-dev-server"></a>①配置webpack-dev-server</h6><p>修改package.json -&gt; scripts中的dev命令，在webpack后面加上serve</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;scripts&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack serve&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行npm run dev，重新打包项目，可以打开localhost:8080，查看自动打包效果</p><h6 id="②解决Cannot-GET-问题"><a href="#②解决Cannot-GET-问题" class="headerlink" title="②解决Cannot GET /问题"></a>②解决Cannot GET /问题</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">//mode用来指定构建模式，可选值有development和production</span><br>    <span class="hljs-comment">//加入下面这段告知 webpack-dev-server，将 &#x27;./&#x27; 目录下的文件 serve 到 localhost:8080 下(寄存到服务器下)</span><br><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">static</span>: <span class="hljs-string">&quot;./&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="③配置html-webpack-plugin"><a href="#③配置html-webpack-plugin" class="headerlink" title="③配置html-webpack-plugin"></a>③配置html-webpack-plugin</h6><p>因为每次打开<a href="http://localhost:8080是一个文件目录而非index.html，所以可以借助html-webpack-plugin把src里的index.html复制到sreve下（内存里）">http://localhost:8080是一个文件目录而非index.html，所以可以借助html-webpack-plugin把src里的index.html复制到sreve下（内存里）</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.导入HTML插件，得到一个构造函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><br><span class="hljs-comment">//2.创建HTML插件的实例对象</span><br><span class="hljs-keyword">const</span> htmlPlugin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>, <span class="hljs-comment">//指定源文件的存放路径</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;./index.html&#x27;</span>, <span class="hljs-comment">//指定生成的文件的存放路径</span><br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;development&#x27;</span>,<br>    <span class="hljs-attr">plugins</span>: [htmlPlugin], <span class="hljs-comment">//3.通过plugins节点，使htmlPlugin生效</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 该插件除了可以复制页面，还会自动注入内存里的webpack打包js</p><h6 id="④devServer节点"><a href="#④devServer节点" class="headerlink" title="④devServer节点"></a>④devServer节点</h6><p>在webpack.config.js文件中，可以新增一个devServer节点，自动打开运行的服务器地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <br><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">static</span>: <span class="hljs-string">&quot;./&quot;</span><br>&#125;,<br><span class="hljs-attr">plugins</span>: [htmlPlugin],<br>    <span class="hljs-attr">devServer</span>:&#123;<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//首次打包成功后，自动打开</span><br>        <span class="hljs-attr">port</span>: <span class="hljs-number">8081</span>, <span class="hljs-comment">//</span><br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> <span class="hljs-comment">//指定运行的地址</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="⑤loder"><a href="#⑤loder" class="headerlink" title="⑤loder"></a>⑤loder</h6><p>非.js后缀结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包，否则会报错</p><p>loader加载器的作用：协助webpack打包处理特定的文件模块，比如：</p><ul><li>css-loader可以打包处理.css相关的文件</li><li>less-loader可以打包处理.less相关的文件</li><li>babel-loader可以打包处理webpack无法处理的高级js语法</li></ul><p><strong>导入css</strong></p><p>在webpack中，一切皆模块，index.js是webpack的入口，一切导入都在此进行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/index.css&#x27;</span><br></code></pre></td></tr></table></figure><p>直接run服务器，会发现报错提示没有合适的loader</p><p><img src="https://s2.loli.net/2022/03/19/UQOArkzV2JTW7eX.png" alt="image-20220319201429493"></p><p>安装loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i style-loader css-loader -D<br></code></pre></td></tr></table></figure><p>然后在webpack.config.js的module -&gt; rules数组中，添加loader规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [ <span class="hljs-comment">//文件后缀名的匹配规则</span><br>        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]&#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>导入less</strong></p><p>配置一个index.less</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">html, body, ul&#123;<br>    <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span>;<br>    li&#123;<br>        line-<span class="hljs-attr">height</span>: 30px;<br>        padding-<span class="hljs-attr">left</span>: 30px;<br>        font-<span class="hljs-attr">size</span>:12px;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行会与前面css一样的问题，所以也需要装loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i less-loader less -D<br></code></pre></td></tr></table></figure><p>添加规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>: [<br>        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>]&#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>导入图片</strong></p><p>导入图片的过程类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i url-loader file0loader<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>: [<br>        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jpg|png|gif$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;url-loader?limit=22229&#x27;</span>&#125;, <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中limit用来指定图片的大小</li><li>只有&lt;=limit大小的图片，才会被转为base64格式的图片</li></ul><p><strong>高级语法的Loader</strong></p><p>js中比如装饰器一类的高级语法webapack无法直接打包，所以也需要loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i babel-loader babel/core @babel/plugin-proposal-decorators -D<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>: [<br>        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>&#125;, <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>注意node_modules里的不用转换，所以要包含exclude: /node_modules/</p><p>具体哪些语法要装哪些loader可以在<a href="https://babeljs.io查阅/">https://babeljs.io查阅</a></p><h5 id="5-发布"><a href="#5-发布" class="headerlink" title="5.发布"></a>5.发布</h5><p>把所有页面打包好发给后端，让后端来部署上线</p><p>在pakage.json文件的scripts节点下，新增build命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;scripts&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack serve&quot;</span>, <span class="hljs-comment">//开发环境中，进行dev命令</span><br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span> <span class="hljs-comment">//项目发布时，运行build命令</span><br>&#125;<br></code></pre></td></tr></table></figure><p>–model是一个参数项，用来指定webpack的运行模式，production代表生产环境，进行代码压缩和性能优化</p><p><strong>注意：</strong>通过–mode方法运行的webpack，会覆盖掉module.export里的mode选项</p><p>运行后打包好的文件就在dist里</p><p>然而打包出来的文件会很乱，所以需要进一步处理</p><p><img src="https://s2.loli.net/2022/03/19/oQKHAGuVWjXLJns.png" alt="image-20220319205505698"></p><h6 id="①把JavaScrip文件统一生产到js目录中"><a href="#①把JavaScrip文件统一生产到js目录中" class="headerlink" title="①把JavaScrip文件统一生产到js目录中"></a>①把JavaScrip文件统一生产到js目录中</h6><p>在webpack.config.js配置文件里的output节点中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>:&#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        <span class="hljs-comment">//明确告诉webpack把生成的bundle.js文件存放到dis目录下的js子目录里</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/bundle.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="②把图片放到images里"><a href="#②把图片放到images里" class="headerlink" title="②把图片放到images里"></a>②把图片放到images里</h6><p>在配置loader的use里用&amp;多加一段参数outputPath=images</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>:&#123;<br>    <span class="hljs-attr">rules</span>: [<br>        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jpg|png|gif$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;url-loader?limit=22229&amp;outputPath=images&#x27;</span>&#125;, <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="③每次发布自动删掉dist文件夹"><a href="#③每次发布自动删掉dist文件夹" class="headerlink" title="③每次发布自动删掉dist文件夹"></a>③每次发布自动删掉dist文件夹</h6><p>安装clean-webpack-plugin插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">plugins</span>:[htmlPlugin, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-SourceMap"><a href="#4-SourceMap" class="headerlink" title="4)SourceMap"></a>4)SourceMap</h4><p>Source Map就是一个信息文件，里面存储着位置信息，SourceMap文件中存储着压缩混淆后的代码，所对应的转换前的位置</p><p>有了它，出错的时候，出错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试</p><p>在webpack.config.js中添加如下配置即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;eval-source-map&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这个做法会暴露源码，直接点击报错信息可以直接定位到源码位置</p><p>如果指向定位报错的具体行数，且不想暴露源码，可以将devtool设置为nosources-source-map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;nosources-source-map&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/19/IqElWTA1Xj3de8p.png" alt="image-20220319211725952"></p><h5 id="1-使用-表示src源码目录"><a href="#1-使用-表示src源码目录" class="headerlink" title="1.使用@表示src源码目录"></a>1.使用@表示src源码目录</h5><p>在导入模块时，可以使用@表示src目录，从外往里找，不要使用../，在webpack.config.js里配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">resolve</span>:&#123;<br>    <span class="hljs-attr">alias</span>:&#123;<br>        <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;./src/&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack-dev-serve遇到Cannot GET 问题的解决方案</title>
    <link href="/blog/2022/03/19/webpack-dev-serve%E9%81%87%E5%88%B0Cannot%20GET%20%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2022/03/19/webpack-dev-serve%E9%81%87%E5%88%B0Cannot%20GET%20%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在使用webpack-dev-serve的时候成功运行了serve，并且在localhost:8080端口运行，但是打开网页只能看到Cannot GET /</p><p><img src="https://s2.loli.net/2022/03/19/4T6b5JGr8WpRlOM.png" alt="image.png"></p><p>排查后发现可能是这个路径的问题</p><p><img src="https://s2.loli.net/2022/03/19/bSpIVFUC6Davs4L.png" alt="image-20220319192900190"></p><p>要设置这个路径的问题很简单，只要在webpack.config.js下做如下修改就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">//mode用来指定构建模式，可选值有development和production</span><br>    <span class="hljs-comment">//加入下面这段告知 webpack-dev-server，将 &#x27;./&#x27; 目录下的文件 serve 到 localhost:8080 下(寄存到服务器下)</span><br><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">static</span>: <span class="hljs-string">&quot;./&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_43131046/article/details/122645224">webpack-dev-serve Cannot GET /_imkaifan的博客-CSDN博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块化与异步编程学习笔记</title>
    <link href="/blog/2022/03/19/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/03/19/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、ES6模块化"><a href="#一、ES6模块化" class="headerlink" title="一、ES6模块化"></a>一、ES6模块化</h3><h4 id="1-ES6模块化定义"><a href="#1-ES6模块化定义" class="headerlink" title="1)ES6模块化定义"></a>1)ES6模块化定义</h4><p>ES6模块化规范中定义：</p><ul><li>每个js文件都是一个独立的模块</li><li>导入其他模块成员使用<strong>import</strong>关键字</li><li>向外共享模块成员使用<strong>export</strong>关键字</li></ul><h4 id="2-ES6模块化的基本语法"><a href="#2-ES6模块化的基本语法" class="headerlink" title="2)ES6模块化的基本语法"></a>2)ES6模块化的基本语法</h4><p>ES6的模块化主要包含以下三种用法：</p><ul><li>默认导出与默认导入</li><li>按需导出与按需导入</li><li>直接导入并执行模块中的代码</li></ul><h5 id="1-默认导出"><a href="#1-默认导出" class="headerlink" title="1.默认导出:"></a>1.默认导出:</h5><p><strong>默认导出的语法</strong>：export default 默认导出的成员</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1_m1.js</span><br><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">10</span> <span class="hljs-comment">//定义模块私有成员n1</span><br><span class="hljs-keyword">let</span> n2 = <span class="hljs-number">20</span> <span class="hljs-comment">//定义模块私有成员n2（外界访问不到n2，因为它没有被共享出去）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">//定义模块私有方法show</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123; <span class="hljs-comment">//使用export default默认导出语法，向外共享你和show两个对象</span><br>    n1,<br>    show<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个模块中，只允许使用<strong>唯一一次</strong>默认导出，否则会报错</li></ul><p><strong>默认导入的语法</strong>：import 接收名称 from ‘模块标识符’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从01_m1.js模块中导入export default向外共享的成员</span><br><span class="hljs-keyword">import</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./01_m1.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1) <span class="hljs-comment">//结果为&#123; n1: 10,show: [function:show] &#125;</span><br></code></pre></td></tr></table></figure><ul><li>接收名称可以任意命名，只要合法就行（按照变量的命名规范，不能数字开头）</li></ul><h5 id="2-按需导出与按需导入"><a href="#2-按需导出与按需导入" class="headerlink" title="2.按需导出与按需导入"></a>2.按需导出与按需导入</h5><p><strong>按需导出的语法</strong>：export 按需导出的成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//03_m2.js</span><br><span class="hljs-comment">//按需导出s1,s2和say()</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&#x27;ccc&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>按需导入的语法：</strong>import{s1} from ‘模块标识符’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//按需导入，用花括号包裹需要导入的成员</span><br><span class="hljs-keyword">import</span> &#123;s1, s2, say&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03_m2.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1) <span class="hljs-comment">//打印输出aa</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>每个模块可以<strong>多次</strong>按需导出</li><li>按需导入的成员名称必须和按需导出的名称保持一致</li><li>按需导入时，可以用as关键字进行重命名</li><li>按需导入可以和默认导入一起使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;s1, s2 <span class="hljs-keyword">as</span> str2, say&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03_m2.js&#x27;</span> <span class="hljs-comment">//把s2重命名为str2</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> info, &#123;s1, s2, say&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03_m2.js&#x27;</span> <span class="hljs-comment">//info是默认导出的成员</span><br></code></pre></td></tr></table></figure><h5 id="3-直接导入并执行模块中的对代码"><a href="#3-直接导入并执行模块中的对代码" class="headerlink" title="3.直接导入并执行模块中的对代码"></a>3.直接导入并执行模块中的对代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//当前模块为05_m3.js</span><br><span class="hljs-comment">//在当前模块中执行一个for循环操作</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = 0l i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//直接导入并执行魔窟啊i代码，不需要得到向外共享的成员</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;05_m3.js&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3)Promise"></a>3)Promise</h4><h5 id="1-回调地狱"><a href="#1-回调地狱" class="headerlink" title="1.回调地狱"></a>1.回调地狱</h5><p>多层回调函数相互嵌套，就形成了回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//回调地狱示例</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;延迟1秒后输出&#x27;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;再延迟2秒后输出&#x27;</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;再延迟3秒后输出&#x27;</span>)<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>代码耦合性太强，牵一发而动全身，难以维护</li><li>大量冗余的代码相互嵌套，代码的可读性变差</li></ul><p>为了解决回调地狱的问题，ES6中新增了Promise的概念</p><h5 id="2-Promise的基本概念"><a href="#2-Promise的基本概念" class="headerlink" title="2.Promise的基本概念"></a>2.Promise的基本概念</h5><p>①Promise是一个构造函数</p><ul><li>我们可以创建Promise的实例 <strong>const p = new Promise()</strong></li><li>new出来的Promise实例对象代表一个<strong>异步操作</strong></li></ul><p>②Promise.prototype上包含一个.then()方法</p><ul><li>每一次new Promise()构造函数得到的实例对象都可以通过原型链的方式访问到.then()方法，例如<strong>p.then()</strong></li></ul><p>③.then()方法用来预先指定成功和失败的回调函数</p><ul><li>p.then(成功的回调函数，失败的回调函数)</li><li>p.then(result =&gt;{}, error =&gt; {})</li><li>调用.then()方法，成功的回调函数是必选的、失败的回调函数是可选的</li></ul><h5 id="3-基于then-fs异步读取文件内容"><a href="#3-基于then-fs异步读取文件内容" class="headerlink" title="3.基于then-fs异步读取文件内容"></a>3.基于then-fs异步读取文件内容</h5><p><strong>回调地狱写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//读取文件1</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err1,r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err1.<span class="hljs-property">message</span>) <span class="hljs-comment">//读取文件1失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1) <span class="hljs-comment">//读取文件1成功</span><br>    <span class="hljs-comment">//读取文件2</span><br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err2,r2</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err1.<span class="hljs-property">message</span>) <span class="hljs-comment">//读取文件2失败</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2) <span class="hljs-comment">//读取文件2成功</span><br>            <span class="hljs-comment">//读取文件3</span><br>            fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err3,r3</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err3.<span class="hljs-property">message</span>) <span class="hljs-comment">//读取文件3失败</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3) <span class="hljs-comment">//读取文件3成功</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>用then-fs写法</strong></p><p>用then-fs提供的readFile()方法，可以异步地读取文件的内容，它的返回值是Promise的实例对象，因此可以调用.then()方法为每个Promise异步操作指定成功和失败后的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><span class="hljs-comment">//注意：.then()中失败回调是可选的，可以被省略</span><br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r1</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)&#125;, <span class="hljs-function"><span class="hljs-params">err1</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err1.<span class="hljs-property">message</span>) &#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r2</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)&#125;, <span class="hljs-function"><span class="hljs-params">err2</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err2.<span class="hljs-property">message</span>) &#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r3</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)&#125;, <span class="hljs-function"><span class="hljs-params">err3</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err3.<span class="hljs-property">message</span>) &#125;)<br></code></pre></td></tr></table></figure><p><strong>注意：上述代码无法保证文件读取顺序，需要进一步改进</strong></p><h5 id="4-then-方法的特性"><a href="#4-then-方法的特性" class="headerlink" title="4..then()方法的特性"></a>4..then()方法的特性</h5><p>如果上一个.then()方法中返回了一个新的Promise实例对象，则可以通过下一个.then()继续进行处理，通过.then()方法的链式调用，就解决了回调地狱的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r1</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br><span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment">//把下一步的操作在第一步里return出来</span><br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r2</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br><span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r3</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="5-通过-catch捕获错误"><a href="#5-通过-catch捕获错误" class="headerlink" title="5.通过.catch捕获错误"></a>5.通过.catch捕获错误</h5><p>在promise的链式操作中如果发生了错误，可以使用Promise.prototype.catch方法进行捕获和处理。</p><p>如果.catch加在最后链式执行过程中遇到错误会马上跳转到.catch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">上一步中的链式操作</span><br><span class="hljs-comment">*/</span><br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果不希望前面的错误导致后续的.then无法正常执行，可以将.catch的调用提前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>) <span class="hljs-comment">//由于错误已经被处理，不影响后续.then的正常执行</span><br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r1</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br><span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment">//把下一步的操作在第一步里return出来</span><br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r2</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br><span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r3</span> =&gt;</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="6-Promise-all-方法"><a href="#6-Promise-all-方法" class="headerlink" title="6.Promise.all()方法"></a>6.Promise.all()方法</h5><p>Promise.all()方法会发起并行的Promise异步操作，等所有的异步操作全部结束后才会执行下一步的.then操作（等待机制）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.定义一个数组，存放3个读文件的异步操作</span><br><span class="hljs-keyword">const</span> promiseArr = [<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>]<br><br><span class="hljs-comment">//2.将Promise的数组，作为Promise.all()的参数</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promiseArr)<br>.<span class="hljs-title function_">then</span>([r1,r2,r3] = &gt; &#123; <span class="hljs-comment">//2.1所有文件读取成功（等待机制）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1,r2,r3)<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123; <span class="hljs-comment">//2.2捕获Promise异步操作中的错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//按照顺序输出全部Promise实例</span><br>[<span class="hljs-number">111</span>,<span class="hljs-number">222</span>,<span class="hljs-number">333</span>]<br></code></pre></td></tr></table></figure><p><strong>注意：数组中Promise实例的顺序，就是最终结果的顺序</strong></p><h5 id="7-Promise-race-方法"><a href="#7-Promise-race-方法" class="headerlink" title="7.Promise.race()方法"></a>7.Promise.race()方法</h5><p>Promise.race()方法会发起并行的Promise异步操作，只要任何一个异步操作完成，就立即执行下一步的.then操作（赛跑机制）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.定义一个数组，存放3个读文件的异步操作</span><br><span class="hljs-keyword">const</span> promiseArr = [<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>    thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>]<br><br><span class="hljs-comment">//2.将Promise的数组，作为Promise.race()的参数</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(promiseArr)<br>.<span class="hljs-title function_">then</span>(result = &gt; &#123; <span class="hljs-comment">//2.1只要任何一个异步操作完成，就立即执行成功的回调函数（赛跑机制）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123; <span class="hljs-comment">//2.2捕获Promise异步操作中的错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//输出跑的最快的那个</span><br>[<span class="hljs-number">333</span>]<br></code></pre></td></tr></table></figure><h5 id="8-基于Promsie封装读文件方法"><a href="#8-基于Promsie封装读文件方法" class="headerlink" title="8.基于Promsie封装读文件方法"></a>8.基于Promsie封装读文件方法</h5><p>写一个方法，直接return new Promise()，然后在Promise的形参里写要执行的操作，就完成了一个Promise方法的封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.方法的名称为getFile</span><br><span class="hljs-comment">//2.方法接收一个形参fpath，表示要读取的文件路径</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>    <span class="hljs-comment">//3.方法的返回值为Promise的实例对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//4.下面这行代码，表示这是一个具体的、读文件的异步操作</span><br>        fs.<span class="hljs-title function_">readFile</span>(fpath,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123; &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-获取-then的两个实参"><a href="#9-获取-then的两个实参" class="headerlink" title="9.获取.then的两个实参"></a>9.获取.then的两个实参</h5><p>通过.then()指定的成功和失败的回调函数，可以在function的形参中进行接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>    <span class="hljs-comment">//resolve 形参是：调用getFiles()方法时，通过.then指定的“成功的”回调函数</span><br>    <span class="hljs-comment">//reject 形参是：调用getFiles()方法时，通过.then指定的“失败的”回调函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(fpath,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123; &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//getFile方法的调用过程</span><br><span class="hljs-title function_">getFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>).<span class="hljs-title function_">then</span>(成功的回调函数，失败的回调函数) <span class="hljs-comment">//成功的回调函数指向resovle，失败的回调函数指向reject</span><br></code></pre></td></tr></table></figure><h5 id="10-调用resolve和reject回调函数"><a href="#10-调用resolve和reject回调函数" class="headerlink" title="10.调用resolve和reject回调函数"></a>10.调用resolve和reject回调函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(fpath,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123; <br>        <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(err) <span class="hljs-comment">//如果读取失败，则调用“失败的回调函数”</span><br>        <span class="hljs-title function_">resolve</span>(dataStr) <span class="hljs-comment">//如果读取成功，则调用“成功的回调函数”</span><br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//r1就是上面resolve里传过来的dataStr，err就是上面reject里传过来的err</span><br><span class="hljs-title function_">getFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span>&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)&#125;, (err) = &gt; &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)&#125;)<br></code></pre></td></tr></table></figure><h4 id="4-async-await"><a href="#4-async-await" class="headerlink" title="4)async/await"></a>4)async/await</h4><h5 id="1-async-await简介"><a href="#1-async-await简介" class="headerlink" title="1.async/await简介"></a>1.async/await简介</h5><p>async/await是ES8引入的新语法，用来简化Promise异步操作，在async/await出现之前，开发者只能通过链式.then()的方式处理Promise异步操作</p><p>.then链式调用解决了回调地狱的问题，但是由代码冗余、阅读性差、不易理解的缺点</p><h5 id="2-async-await的基本使用"><a href="#2-async-await的基本使用" class="headerlink" title="2.async/await的基本使用"></a>2.async/await的基本使用</h5><p>使用async/await简化Promise异步操作的示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-comment">//按照顺序读取文件1，2，3的内容</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllFile</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-comment">//使用await后，返回的不再是promise实例，而是一个真正的值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>    <span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>    <span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>&#125;<br><br><span class="hljs-title function_">getAllFile</span>()<br></code></pre></td></tr></table></figure><h5 id="3-async-await的使用注意事项"><a href="#3-async-await的使用注意事项" class="headerlink" title="3.async/await的使用注意事项"></a>3.async/await的使用注意事项</h5><ul><li>如果function中使用await，则function必须被async修饰</li><li>在async方法中，第一个await之前的代码会同步执行，await之后的代码会异步执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment">//最先输出</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllFile</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-comment">//没有await，先同步执行</span><br>    <br>    <span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-comment">//检测到异步操作，先入堆，执行后面的操作</span><br>    <span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">await</span> thenFS.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1,r2,r3) <span class="hljs-comment">//同步操作处理完了，再处理异步操作，await全部处理完后执行此处同步操作</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;D&#x27;</span>)<span class="hljs-comment">//最后输出</span><br>&#125;<br><br><span class="hljs-title function_">getAllFile</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>) <span class="hljs-comment">//第二步执行的操作</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//输出顺序</span><br>A<br>B<br>C<br><span class="hljs-number">111</span> <span class="hljs-number">222</span> <span class="hljs-number">333</span><br>D<br></code></pre></td></tr></table></figure><h4 id="5）EventLoop"><a href="#5）EventLoop" class="headerlink" title="5）EventLoop"></a>5）EventLoop</h4><h5 id="1-JavaScript是单线程语言"><a href="#1-JavaScript是单线程语言" class="headerlink" title="1.JavaScript是单线程语言"></a>1.JavaScript是单线程语言</h5><p>JavaScript是单线程语言是一门单线程执行的编程语言，同一时间只能做一件事情</p><p><img src="https://s2.loli.net/2022/03/19/6DIVJKswiSnrTyA.png" alt="image-20220319150317064"></p><p>单线程执行任务队列的问题：</p><p>如果前一个任务非常耗时，则后续的任务就不得不一致等待，从而导致程序假死的问题</p><h5 id="2-EventLoop的基本概念"><a href="#2-EventLoop的基本概念" class="headerlink" title="2.EventLoop的基本概念"></a>2.EventLoop的基本概念</h5><p><img src="https://s2.loli.net/2022/03/19/PzJbDc4XiU19KAI.png" alt="image-20220319151304663"></p><p>JavaScript主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为EventLoop（事件循环）</p><h4 id="6）宏任务和微任务"><a href="#6）宏任务和微任务" class="headerlink" title="6）宏任务和微任务"></a>6）宏任务和微任务</h4><h6 id="1-宏任务和微任务分类"><a href="#1-宏任务和微任务分类" class="headerlink" title="1.宏任务和微任务分类"></a>1.宏任务和微任务分类</h6><p>JavaScript把异步任务又做了进一步的划分，异步任务又分为两类，分别是</p><p>①宏任务(macrotask)</p><ul><li>异步Ajax请求</li><li>setTimeout、setInterval</li><li>文件操作</li><li>其他宏任务</li></ul><p>②微任务(microtask)</p><ul><li>Promise.then、.catch和.finally</li><li>process.nextTick</li><li>其他微任务</li></ul><p><img src="https://s2.loli.net/2022/03/19/PVRdxG2XOum93q6.png" alt="image-20220319152021437"></p><p><strong>注意：new Promise(）是一个同步任务</strong></p><h5 id="２-宏任务和微任务的执行顺序"><a href="#２-宏任务和微任务的执行顺序" class="headerlink" title="２.宏任务和微任务的执行顺序"></a>２.宏任务和微任务的执行顺序</h5><p><img src="https://s2.loli.net/2022/03/19/4OUSd5HvoqJm8Be.png" alt="image-20220319152136761"></p><p>每一个宏任务执行完成后，都会检查是否存在待执行的微任务，</p><p>如果由，则执行完所有微任务之后，再执行下一个宏任务</p><p>类比于银行业务，宏任务为客户，微任务为客户要执行的操作，执行完一个客户的所有需要之后才会接待下一个顾客</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax学习笔记</title>
    <link href="/blog/2022/03/19/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/03/19/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、服务器与客户端"><a href="#一、服务器与客户端" class="headerlink" title="一、服务器与客户端"></a>一、服务器与客户端</h3><p><img src="https://s2.loli.net/2022/03/18/oPvxsOjHABYEWhk.png" alt="image.png"></p><h4 id="1）网页中如何请求数据"><a href="#1）网页中如何请求数据" class="headerlink" title="1）网页中如何请求数据"></a>1）网页中如何请求数据</h4><p>如果需要在网页中请求服务器上的数据资源，则需要用到XMLHttpRequest对象</p><p>XMLHttpRequest(简称xhr)是浏览器提供的js成员，通过它，可以请求服务器上的数据资源</p><p>最简单的用啊：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhrObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br></code></pre></td></tr></table></figure><h4 id="2-资源的请求方式"><a href="#2-资源的请求方式" class="headerlink" title="2)资源的请求方式"></a>2)资源的请求方式</h4><p>请求方式有许多种，最常见的是get和post请求</p><ul><li>get请求通常用于获取服务端资源（向服务器要资源） 例如：根据URL地址，从服务器获取HTML文件、CSS文件、JS文件、图片文件、数据资源等</li><li>post请求通常用于向服务器提交数据（往服务器发送资源）例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息等</li></ul><h4 id="3-Ajax"><a href="#3-Ajax" class="headerlink" title="3)Ajax"></a>3)Ajax</h4><p>Ajax的全称是Asynchronous Javascript And XML(异步JavaScript和XML)</p><p>通俗理解：利用XMLHttpRequest进行交互</p><h4 id="4）JQuery中的Ajax"><a href="#4）JQuery中的Ajax" class="headerlink" title="4）JQuery中的Ajax"></a>4）JQuery中的Ajax</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">get</span>(url,[data],callback)<br>$.<span class="hljs-title function_">post</span>(url,[data],callback)<br>$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//请求方式,get或post</span><br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">data</span>:&#123;&#125;,<br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123; &#125;<span class="hljs-comment">//回到函数</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="5-接口"><a href="#5-接口" class="headerlink" title="5)接口"></a>5)接口</h4><p>使用Ajax请求数据时，被请求的URL地址，就叫做数据接口（简称接口），同时，每个接口必须有请求方式</p><p>例如</p><p><a href="http://www.liulongbin.top:3006/api/getbooks">http://www.liulongbin.top:3006/api/getbooks</a> 获取图书列表的接口（GET请求）</p><p><a href="http://www.liulongbin.top:3006/api/addbooks">http://www.liulongbin.top:3006/api/addbooks</a> 添加图书列表的接口（POST请求）</p><h3 id="二、form表单的基本使用"><a href="#二、form表单的基本使用" class="headerlink" title="二、form表单的基本使用"></a>二、form表单的基本使用</h3><h4 id="1）标签的属性"><a href="#1）标签的属性" class="headerlink" title="1）标签的属性"></a>1）<form>标签的属性</h4><ul><li><p>action属性用来规定当前提交表单时，向何处发送表单数据</p></li><li><p>target属性用来规定在何处打开action URL</p></li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>_blank</td><td>在新窗口中打开</td></tr><tr><td>_self</td><td>默认。在相同框架中打开</td></tr><tr><td>_parent</td><td>在父框架集中打开（很少用）</td></tr><tr><td>_top</td><td>在整个窗口中打开（很少用）</td></tr><tr><td>framename</td><td>在指定框架中打开（很少用）</td></tr></tbody></table><ul><li><p>method属性用来规定以何种方式把表单数据提交到html(get、post，默认get)</p></li><li><p>enctype 属性用来规定发送编码</p></li></ul><p>涉及到文件上传操作时，必须将enctype设置为multipart/form-data</p><p>默认值为application/x-www-form-urlencoded ，不涉及文件上传不需要改</p><h4 id="2-表单的同步提交"><a href="#2-表单的同步提交" class="headerlink" title="2)表单的同步提交"></a>2)表单的同步提交</h4><p>通过点击submit按钮，触发表单提交的操作，从而使页面跳转到action URL的行为，叫做表单的同步提交</p><p><strong>表单的同步提交的缺点</strong></p><ol><li>页面会发生跳转</li><li>页面之前的状态和数据会丢失</li></ol><p>解决方案：表单只负责采集数据，Ajax负责将数据提交到服务器</p><h3 id="三、Ajax加强"><a href="#三、Ajax加强" class="headerlink" title="三、Ajax加强"></a>三、Ajax加强</h3><h4 id="1）XMLHttpRequest的基本使用"><a href="#1）XMLHttpRequest的基本使用" class="headerlink" title="1）XMLHttpRequest的基本使用"></a>1）XMLHttpRequest的基本使用</h4><p><img src="https://s2.loli.net/2022/03/18/QB6IoWshtdRJTF2.png" alt="image.png"></p><h5 id="1-使用xhr发起get请求"><a href="#1-使用xhr发起get请求" class="headerlink" title="1.使用xhr发起get请求"></a>1.使用xhr发起get请求</h5><p>​    ①创建xhr对象</p><p>​    ②调用xhr.open()函数</p><p>​    ③调用xhr.send()函数</p><p>​    ④监听xhr.onreadystatechange事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建xhr对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequst</span>()<br><span class="hljs-comment">//2.调用open函数，指定请求方式与URL地址</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)<br><span class="hljs-comment">//3.调用send函数，发起Ajax请求</span><br>xhr.<span class="hljs-title function_">send</span>()<br><span class="hljs-comment">//4.监听onreadystatechange事件</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//4.1监听xhr对象的请求状态(readyState)与服务器响应的状态(status)</span><br>    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-comment">//数据获取成功</span><br>        <span class="hljs-comment">//4.2打印服务器响应回来的数据</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">reponseText</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-了解xhr对象的readyState属性"><a href="#2-了解xhr对象的readyState属性" class="headerlink" title="2.了解xhr对象的readyState属性"></a>2.了解xhr对象的readyState属性</h5><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>UNSENT</td><td>XMLHttpRequest对象已被创建，但尚未调用open()方法</td></tr><tr><td>1</td><td>OPENED</td><td>open()方法已经被调用</td></tr><tr><td>2</td><td>HEADERS_RECEIVED</td><td>send()方法已经被调用，响应头也已经被接收</td></tr><tr><td>3</td><td>LOADING</td><td>数据接收中，此时response属性中已经包含部分数据</td></tr><tr><td>4</td><td>DONE</td><td>Ajax请求完成，这意味着数据传输已经彻底完成或失败</td></tr></tbody></table><h5 id="3-使用xhr发起带参数的GET请求"><a href="#3-使用xhr发起带参数的GET请求" class="headerlink" title="3.使用xhr发起带参数的GET请求"></a>3.使用xhr发起带参数的GET请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;</span>) <span class="hljs-comment">//在后面加问号&#x27;?&#x27;和参数</span><br></code></pre></td></tr></table></figure><p>这种在URL地址后面拼接的参数，叫做查询字符串</p><h5 id="4-查询字符串"><a href="#4-查询字符串" class="headerlink" title="4.查询字符串"></a>4.查询字符串</h5><p>定义：查询字符串(URL参数)是指在URL的末尾加上用于向服务器发送信息的字符串（变量）</p><p>格式：将英文的?放在URL的末尾，然后再加上参数=值，想加上多个参数的话，使用&amp;符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL中</p><h5 id="5-URL编码"><a href="#5-URL编码" class="headerlink" title="5.URL编码"></a>5.URL编码</h5><p>URL编码：使用英文字符去表示非英文字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记&#x27;</span>)<br><span class="hljs-comment">//经过URL编码后</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=%E%A%5%BF%E6%B8%D8%E8%AE%B0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>浏览器提供了URL编码与解码的API，分别是：</p><ul><li>encodeURI()编码的函数</li><li>decodeURI()解码的函数</li></ul><h5 id="6-使用xhr发起POST请求"><a href="#6-使用xhr发起POST请求" class="headerlink" title="6.使用xhr发起POST请求"></a>6.使用xhr发起POST请求</h5><p>步骤：</p><p>​    ①创建xhr对象</p><p>​    ②调用xhr.open()函数</p><p>​    ③设置Content-Type属性（固定写法）</p><p>​    ④调用xhr.send()函数，同时指定要发送的数据</p><p>​    ⑤监听xhr.onreadystatechange事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建xhr对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequst</span>()<br><span class="hljs-comment">//2.调用open函数，指定请求方式与URL地址</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbooks&#x27;</span>)<br><span class="hljs-comment">//3.设置Content-Type属性（固定写法）</span><br>xhr.<span class="hljs-title function_">setRequestHead</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;application/x-www-form-urlencod&#x27;</span>)<br><span class="hljs-comment">//4.调用send函数，同时将数据以查询字符串的形式，提交给服务器</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;</span>)<br><span class="hljs-comment">//5.监听onreadystatechange事件</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//4.1监听xhr对象的请求状态(readyState)与服务器响应的状态(status)</span><br>    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-comment">//数据获取成功</span><br>        <span class="hljs-comment">//4.2打印服务器响应回来的数据</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">reponseText</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-数据交换格式"><a href="#2-数据交换格式" class="headerlink" title="2)数据交换格式"></a>2)数据交换格式</h4><p>数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式</p><p>前端领域，经常提及的两种交换格式分别是XML和JSON，其中JSON用的最多</p><h5 id="1-XML"><a href="#1-XML" class="headerlink" title="1.XML"></a>1.XML</h5><p>XML全称是Extensible Markup Language，即可扩展标记语言</p><p>XML和HTML虽然都是标记语言，但是它们之间没有任何关系</p><ul><li>HTML被设计用来描述网页上的内容，是网页内容的载体</li><li>XML被设计用来传输和存储数据，是数据的载体</li></ul><p><strong>XML的缺点</strong></p><p>①格式臃肿，和数据无关的代码多，体积大，传输效率低</p><p>②在JS中解析XML比较麻烦</p><h5 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2.JSON"></a>2.JSON</h5><p>JSON全称是JavaScript Object Notation，即“JavaScript对象表示法”，JSON就是JS中对象和数组的字符串表示法，他使用文本表示一个和JS对象或数组的信息，因此，JSON的本质就是字符串</p><p>作用：轻量级的文本数据交换格式，更小、更快、更易解析</p><h5 id="3-JSON的两种结构"><a href="#3-JSON的两种结构" class="headerlink" title="3.JSON的两种结构"></a>3.JSON的两种结构</h5><p>对象结构：对象结构在JSON中表示为用{}括起来的内容，数据结构为{key:value,key:value,….}的键值对形式，key必须是英文的双引号包裹的字符串，value可以是数字、字符串（也要双引号包裹）、布尔值、null、数组、对象6种属性（不能是undefine、function）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;zs&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">20</span>,<br>   <span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组结构：数组结构在JSON种表示为[]括起来的内容。数据结构为[“java”,”javascript”,30,true…]。数组种数据的类型可以是数字、字符串（也要双引号包裹）、布尔值、null、数组、对象6种属性（不能是undefine、function）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><h5 id="4-JSON和JS对象的互转"><a href="#4-JSON和JS对象的互转" class="headerlink" title="4.JSON和JS对象的互转"></a>4.JSON和JS对象的互转</h5><p>JSON -&gt; obj:  JSON.parse()  称作JSON反序列化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;&#125;&#x27;</span>)<br><span class="hljs-comment">//结果是&#123;a:&#x27;Hello&#x27;,b:&#x27;World&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>obj -&gt; JSON: JSON.stringify() 称作JSON序列化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br><span class="hljs-comment">//结果是&#x27;&#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="3）XMLHttpRequest-Level2的新特性"><a href="#3）XMLHttpRequest-Level2的新特性" class="headerlink" title="3）XMLHttpRequest Level2的新特性"></a>3）XMLHttpRequest Level2的新特性</h4><h5 id="1-旧版XHR的缺点"><a href="#1-旧版XHR的缺点" class="headerlink" title="1.旧版XHR的缺点"></a>1.旧版XHR的缺点</h5><p>①只支持文本数据的传输，无法用来读取和上传文件</p><p>②传送和接收数据时，没有进度信息，只能提升有没有完成</p><h5 id="2-XMLHttpRequest-Level2的新功能"><a href="#2-XMLHttpRequest-Level2的新功能" class="headerlink" title="2.XMLHttpRequest Level2的新功能"></a>2.XMLHttpRequest Level2的新功能</h5><p>①可以设置HTTP请求的时限</p><p>②可以使用FormData对象管理表单数据</p><p>③可以上传文件</p><p>④可以获得数据传输的进度信息</p><h5 id="3-设置HTTP请求时限"><a href="#3-设置HTTP请求时限" class="headerlink" title="3.设置HTTP请求时限"></a>3.设置HTTP请求时限</h5><p>xhr的timeout属性可以设置时限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">3000</span> <span class="hljs-comment">//3000毫秒</span><br></code></pre></td></tr></table></figure><p>与之配套的还有一个timeout事件，用来指定回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-title function_">finction</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请求超时！&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-FormData对象管理表单数据"><a href="#4-FormData对象管理表单数据" class="headerlink" title="4.FormData对象管理表单数据"></a>4.FormData对象管理表单数据</h5><p>FormData模拟表单提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.新建FormData对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br><span class="hljs-comment">//2.为FormData添加表单项</span><br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uname&#x27;</span>,<span class="hljs-string">&#x27;zs&#x27;</span>)<br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;upwd&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>)<br><span class="hljs-comment">//3.创建XHR对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">//4.指定请求类型与URL地址</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;URL&#x27;</span>)<br><span class="hljs-comment">//5.直接提交FormData对象，与提交网页表单的效果完全一样</span><br>xhr.<span class="hljs-title function_">send</span>(fd)<br></code></pre></td></tr></table></figure><p>FormData也可以用来获取网页表单的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//获取表单元素</span><br><span class="hljs-keyword">var</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#form1&#x27;</span>)<br><span class="hljs-comment">//监听表单的submit事件</span><br>form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-params"><span class="hljs-string">&#x27;submit&#x27;</span>,cuntion(e)</span>)&#123;<br>    e.<span class="hljs-title function_">preventDefault</span>() <span class="hljs-comment">//阻止默认提交</span><br>    <span class="hljs-comment">//根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中</span><br>    <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DormData</span>(form)<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;URL&#x27;</span>)<br>    xhr.<span class="hljs-title function_">send</span>(fd)<br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-上传文件"><a href="#5-上传文件" class="headerlink" title="5.上传文件"></a>5.上传文件</h5><p>①定义UI结构</p><p>②验证是否选择了文件</p><p>③向FormData中追加文件</p><p>④使用xhr发起上传文件的请求</p><p>⑤监听onreadystatechange事件</p><h6 id="1-定义UI结构"><a href="#1-定义UI结构" class="headerlink" title="1.定义UI结构"></a><strong>1.定义UI结构</strong></h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1.文件选择框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file1&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 2.上传按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnUpload&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 3.显示上传到服务器上的图片 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h6 id="2-验证是否选择了文件"><a href="#2-验证是否选择了文件" class="headerlink" title="2.验证是否选择了文件"></a><strong>2.验证是否选择了文件</strong></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.获取上传文件按钮</span><br><span class="hljs-keyword">var</span> btnUpload = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>)<br><span class="hljs-comment">//2.为按钮添加click事件监听</span><br>btnUpload.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//3.获取到选择的文件列表</span><br>    <span class="hljs-keyword">var</span> files = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#file1&#x27;</span>).<span class="hljs-property">files</span><br>    <span class="hljs-keyword">if</span>(files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//判断是否有文件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择要上传的文件！&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h6 id="3-向FormData中追加文件"><a href="#3-向FormData中追加文件" class="headerlink" title="3.向FormData中追加文件"></a><strong>3.向FormData中追加文件</strong></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建FormData对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br><span class="hljs-comment">//2.向FormData中追加文件</span><br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avartor&#x27;</span>,files[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h5 id="6-显示文件上传进度"><a href="#6-显示文件上传进度" class="headerlink" title="6.显示文件上传进度"></a>6.显示文件上传进度</h5><p>可以通过监听xhr.upload.onprogress事件来获取文件的上传进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">//监听xhr.upload的onprogress事件</span><br>xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-comment">//e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度</span><br>    <span class="hljs-keyword">if</span>(e.<span class="hljs-property">lengthComputable</span>)&#123;<br><span class="hljs-comment">//e.loaded已传输的字节</span><br>      <span class="hljs-comment">//e,total需传输的字节</span><br>        <span class="hljs-keyword">var</span> percentComplete = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-axios"><a href="#4-axios" class="headerlink" title="4)axios"></a>4)axios</h4><p>Axios是专注于网络数据请求的库</p><p>相比于原生的XMLHttpRequest对象，axios更简单易用</p><p>相比于jQuery，axios更加轻量化，只专注于网络数据请求</p><p><strong>axios发起get请求的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>,&#123;<span class="hljs-attr">params</span>:&#123;<span class="hljs-comment">/*参数*/</span>&#125;&#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><p><strong>axios发起post请求的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;url&#x27;</span>,&#123;<span class="hljs-comment">/*参数*/</span>&#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><p><strong>直接使用axios发起请求</strong></p><p>axios也提供了类似于jQuery中$.ajax()的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;请求类型&#x27;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;请求的URL地址&#x27;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<span class="hljs-comment">/*post数据*/</span>&#125;,<br>    <span class="hljs-attr">params</span>:&#123;<span class="hljs-comment">/*GET参数*/</span>&#125;<br>&#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><h3 id="四、跨域和JSONP"><a href="#四、跨域和JSONP" class="headerlink" title="四、跨域和JSONP"></a>四、跨域和JSONP</h3><h4 id="1）同源策略和跨域"><a href="#1）同源策略和跨域" class="headerlink" title="1）同源策略和跨域"></a>1）同源策略和跨域</h4><p>如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源</p><p><strong>同源策略</strong></p><p>全称(Same origin policy)是浏览器提供的一个安全功能</p><p>MDN官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何于来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>通俗的理解：浏览器规定，A网站的JavaScript，不允许和非同源的网站C之间，进行资源的交互，例如：</p><p>①无法读取非同源网页的Cookie、LocalStorage和IndexedDB</p><p>②无法接触非同源网站的DOM</p><p>③无法向非同源地址发送Ajax请求</p><p><strong>跨域</strong></p><p>只要不同源就是跨域</p><p>出现跨域的根本原因：浏览器的同源策略不允许非同源的URL之间进行资源的交互</p><p><strong>如何实现跨域数据请求</strong></p><p>主要两种解决方案：JSONP和CORS</p><p>JSONP：出现的早，兼容性好，临时解决方案，只支持GET请求</p><p>CORS：出现的较晚，是W3C标准，属于跨域Ajax请求的根本解决方案，支持GET和POST请求，缺点是不兼容低版本浏览器</p><h4 id="2）JSONP"><a href="#2）JSONP" class="headerlink" title="2）JSONP"></a>2）JSONP</h4><p>JSONP（JSON with Padding)是JSON的一种”使用模式“，可用于解决主流浏览器的跨域数据访问的问题</p><p>原理：&lt;script&gt;标签不受浏览器同源策略的影响，可以通过src属性，请求非同源的js脚本</p><p>因此，JSONP的实现原理，就是通过&lt;script&gt;标签的src属性，请求跨域的数据接口，并通过函数调用的形式接收跨域接口响应会回来的数据。</p><h4 id="3）防抖"><a href="#3）防抖" class="headerlink" title="3）防抖"></a>3）防抖</h4><p>防抖策略（debounce）是当事件触发后，延迟n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>能够保证事件被反复触发的时候回调只触发一次</p><p><img src="https://s2.loli.net/2022/03/18/bej7lmkExu9Angr.png" alt="image.png"></p><p><strong>实现输入框防抖</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span> <span class="hljs-comment">//1.防抖的timer</span><br><br>functiopn <span class="hljs-title function_">debounceSearch</span>(<span class="hljs-params">keywords</span>)&#123; <span class="hljs-comment">//2.定义防抖的函数</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-title function_">funciton</span>(<span class="hljs-params"></span>)&#123;<br>                      <span class="hljs-comment">//发起JSONP请求</span><br>                       <span class="hljs-title function_">getSuggestList</span>(keywords)<br>                       &#125;,<span class="hljs-number">500</span>)<br>&#125;<br>$(<span class="hljs-string">&#x27;#ipt&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <span class="hljs-title function_">debounceSearch</span>(keywords)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="4-节流"><a href="#4-节流" class="headerlink" title="4)节流"></a>4)节流</h4><p>节流策略（throttle)，可以减少一段时间内事件的触发频率</p><p><strong>节流的应用场景</strong></p><p>①鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p><p>②懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不去浪费CPU资源</p><h4 id="五、HTTP协议"><a href="#五、HTTP协议" class="headerlink" title="五、HTTP协议"></a>五、HTTP协议</h4><h5 id="1-HTTP协议简介"><a href="#1-HTTP协议简介" class="headerlink" title="1.HTTP协议简介"></a>1.HTTP协议简介</h5><p>通信协议（Communication protocol)是指通信的双方完成通信所必须遵守的规则和约定。</p><p>通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫通信协议</p><p>网络内容的传输协议又叫做超文本传输协议（HyperText Transfer Protocol）简称HTTP协议</p><h5 id="2-HTTP请求消息的组成部分"><a href="#2-HTTP请求消息的组成部分" class="headerlink" title="2.HTTP请求消息的组成部分"></a>2.HTTP请求消息的组成部分</h5><p>HTTP请求消息由请求行(request line)、请求头部(header)、空行和请求体4个部分组成。</p><p><img src="https://s2.loli.net/2022/03/18/2b4F6PsyUcmVNgG.png" alt="image.png"></p><p><strong>请求行的组成</strong></p><p><img src="https://s2.loli.net/2022/03/18/xlz8ytTib3fGmMI.png" alt="image.png"></p><p><strong>请求头部</strong></p><p>请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器</p><ul><li>User-Agent说明当前是什么浏览器</li><li>Content-Type用来描述发送到服务器的数据格式</li><li>Accept用来描述客户端能够接收什么类型的返回内容；</li><li>Accept-Languege用来描述客户端期望接收哪种人类语言的文本内容</li></ul><p>请求头由多行键值对组成，每行的键和值之间用英文的冒号分割</p><p><strong>空行</strong></p><p>最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束，用来分割请求头和请求体</p><p><strong>请求体</strong></p><p>请求体中存放的，是要通过POST方式提交到服务器的数据，只有POST请求才有，GET请求没有</p><h5 id="3-HTTP响应消息"><a href="#3-HTTP响应消息" class="headerlink" title="3.HTTP响应消息"></a>3.HTTP响应消息</h5><p>HTTP响应消息由状态行、响应头部、空行和响应体四个部分组成</p><p><img src="https://s2.loli.net/2022/03/18/JjGAo1ZzagcQOLM.png" alt="image.png"></p><p><strong>状态行</strong></p><p>状态行由HTTP协议版本、状态码和状态码的描述文本3个部分组成，他们之间用空格隔开</p><p><img src="https://s2.loli.net/2022/03/18/VzY2WoGOaMj3ch4.png" alt="image.png"></p><p><strong>响应头部</strong></p><p>响应头部用来描述服务器的基本信息，响应头部由多行键值对组成</p><p><img src="https://s2.loli.net/2022/03/18/AFfIRg9uPL6vC2m.png" alt="image.png"></p><p><strong>空行</strong></p><p>分割响应头部和响应体</p><h4 id="4-HTTP请求方法"><a href="#4-HTTP请求方法" class="headerlink" title="4.HTTP请求方法"></a>4.HTTP请求方法</h4><p>HTTP请求方法用来表明要对服务器上的资源执行的操作，最常见的是GET和POST</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>查询</td></tr><tr><td>2</td><td>POST</td><td>新增</td></tr><tr><td>3</td><td>PUT</td><td>修改</td></tr><tr><td>4</td><td>DELETE</td><td>删除</td></tr><tr><td>5</td><td>HEAD</td><td>与GET类似，没有响应体</td></tr><tr><td>6</td><td>OPTIONS</td><td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等</td></tr><tr><td>7</td><td>CONNECT</td><td>建立一个到由目标资源标识的服务器的隧道</td></tr><tr><td>8</td><td>TRACE</td><td>沿着目标资源的路径执行一个消息环回测试，主要用于测试或诊断</td></tr><tr><td>9</td><td>PATCH</td><td>是对PUT方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h5 id="5-HTTP响应状态码"><a href="#5-HTTP响应状态码" class="headerlink" title="5.HTTP响应状态码"></a>5.HTTP响应状态码</h5><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到）</td></tr><tr><td>2**</td><td>成功</td></tr><tr><td>3**</td><td>重定向，需要进一步操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p><strong>常见的2**成功相关响应状态码</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建，成功请求并创建了新的资源，通常用于POST或PUT请求</td></tr></tbody></table><p><strong>常见的3**成功相关响应状态码</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久移动，请求的资源已经被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新的URI，今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动，与301类似，但资源只是临时被移动，客户端应继续使用原有的URI</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改，所请求的资源未修改，服务器返回次状态码时，不会返回任何资源（响应消息中不包含响应体），客户端通常会缓存访问过的资源</td></tr></tbody></table><p><strong>常见的4**成功相关响应状态码</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>1、语法有误 2、请求参数有误</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时，服务器等待客户端发送的请求时间过长，超时</td></tr></tbody></table><p><strong>常见的5**成功相关响应状态码</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>500</td><td>Internal Sever Error</td><td>服务器内部错误</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持改请求方法，只有GET和HEAD请求是要求每个服务器必须支持的</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时无法处理客户端请求</td></tr></tbody></table><h4 id="五、GIT"><a href="#五、GIT" class="headerlink" title="五、GIT"></a>五、GIT</h4><h4 id="1-Git中的三个区域"><a href="#1-Git中的三个区域" class="headerlink" title="1.Git中的三个区域"></a>1.Git中的三个区域</h4><p>工作区：处理工作的区域</p><p>暂存区：已完成的工作的临时存放区域，等待被提交</p><p>Git仓库：最终存放区域</p><h4 id="2-Git中的三种状态"><a href="#2-Git中的三种状态" class="headerlink" title="2.Git中的三种状态"></a>2.Git中的三种状态</h4><p>已修改(modified)：修改了文件，但还没将修改的结果放到暂存区</p><p>已暂存(staged)：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表种</p><p>已提交(committed)：表示文件已经安全地保存在本地的Git仓库中</p><h4 id="3-工作区中文件的4种状态"><a href="#3-工作区中文件的4种状态" class="headerlink" title="3.工作区中文件的4种状态"></a>3.工作区中文件的4种状态</h4><p><img src="https://s2.loli.net/2022/03/19/aVdWl9piI6D4TFM.png" alt="image-20220318211926633"></p><h4 id="4-跳过使用暂存区域"><a href="#4-跳过使用暂存区域" class="headerlink" title="4.跳过使用暂存区域"></a>4.跳过使用暂存区域</h4><p><img src="https://s2.loli.net/2022/03/19/wYFeo9n7WgN4k56.png" alt="image-20220318212301792"></p><h4 id="5-移除文件"><a href="#5-移除文件" class="headerlink" title="5.移除文件"></a>5.移除文件</h4><p><img src="https://s2.loli.net/2022/03/19/JbPLBfIHZcG8CXe.png" alt="image-20220318212406963"></p><h5 id="6-gitignore"><a href="#6-gitignore" class="headerlink" title="6. .gitignore"></a>6. .gitignore</h5><p><img src="https://s2.loli.net/2022/03/19/rxfMK5wBAsmv9o6.png" alt="image-20220318212600657"></p><h5 id="7-查看提交历史"><a href="#7-查看提交历史" class="headerlink" title="7.查看提交历史"></a>7.查看提交历史</h5><p><img src="https://s2.loli.net/2022/03/19/IKs2gU9THmlzFwN.png" alt="image-20220318212639718"></p><h5 id="8-回退到指定版本"><a href="#8-回退到指定版本" class="headerlink" title="8.回退到指定版本"></a>8.回退到指定版本</h5><p><img src="https://s2.loli.net/2022/03/19/mTzBnjPDf6KRixV.png" alt="image-20220318212711419"></p><h5 id="9-上传GitHub"><a href="#9-上传GitHub" class="headerlink" title="9.上传GitHub"></a>9.上传GitHub</h5><p><img src="https://s2.loli.net/2022/03/19/WHnFjoZds1LPhv3.png" alt="image-20220318212940161"></p><h5 id="10-分支的作用"><a href="#10-分支的作用" class="headerlink" title="10.分支的作用"></a>10.分支的作用</h5><p><img src="https://s2.loli.net/2022/03/19/pxhiMtAP5IdK71o.png" alt="image-20220318213113191"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript进阶与ES6学习笔记</title>
    <link href="/blog/2022/03/17/JavaScript%E8%BF%9B%E9%98%B6%E4%B8%8EES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/03/17/JavaScript%E8%BF%9B%E9%98%B6%E4%B8%8EES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h3><h4 id="1）面向对象的特性："><a href="#1）面向对象的特性：" class="headerlink" title="1）面向对象的特性："></a><strong>1）面向对象的特性：</strong></h4><ol><li>封装性</li><li>继承性</li><li>多态性</li></ol><p>面向过程：</p><ul><li>优点：性能高，适合硬件</li><li>缺点：没有面向对象易维护，易复用，易扩展</li></ul><p>面向对象：</p><ul><li>有点：易维护，易复用，易扩展，由于封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><h4 id="2）ES6中的类和对象"><a href="#2）ES6中的类和对象" class="headerlink" title="2）ES6中的类和对象"></a><strong>2）ES6中的类和对象</strong></h4><p><strong>创建类</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">className</span></span>&#123;<br>    <span class="hljs-comment">//类内容</span><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-type">Star</span>(); <span class="hljs-comment">//实例化</span><br></code></pre></td></tr></table></figure><h5 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a><strong>constructor构造函数</strong></h5><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uname</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span> <span class="hljs-operator">=</span> <span class="hljs-variable">uname</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-variable">ldh</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>);<br></code></pre></td></tr></table></figure><p>创建类，类名后面不要加小括号，生成实例一定要加小括号</p><h5 id="类中添加方法"><a href="#类中添加方法" class="headerlink" title="类中添加方法"></a><strong>类中添加方法</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span>&#123;<br>    <span class="hljs-title function_">sing</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sing&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>类内函数不需要写function</li><li>多个函数之间不需要添加逗号分割</li></ol><h5 id="类的继承extends"><a href="#类的继承extends" class="headerlink" title="类的继承extends"></a><strong>类的继承extends</strong></h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//父类</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//子类</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><strong>super关键字</strong></h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//父类</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//子类</span><br>    constructor(x,y)&#123;<br>        <span class="hljs-keyword">super</span>(x,y); <span class="hljs-comment">//调用了父类中的构造函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="super调用父类的普通方法"><a href="#super调用父类的普通方法" class="headerlink" title="super调用父类的普通方法"></a><strong>super调用父类的普通方法</strong></h5><p>继承中的就近原则：</p><ol><li>继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，有就先执行子类的</li><li>继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）</li></ol><h5 id="super必须在子类this之前"><a href="#super必须在子类this之前" class="headerlink" title="super必须在子类this之前"></a><strong>super必须在子类this之前</strong></h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//父类</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">//子类</span><br>    constructor(x,y)&#123;<br>        <span class="hljs-comment">//必须先调用父类构造函数，再调用子类构造方法</span><br>        <span class="hljs-comment">//super必须在子类this之前</span><br>        <span class="hljs-keyword">super</span>(x,y); <span class="hljs-comment">//调用了父类中的构造函数</span><br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用类的注意事项："><a href="#使用类的注意事项：" class="headerlink" title="使用类的注意事项："></a><strong>使用类的注意事项：</strong></h5><ol><li>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</li><li>类里面的共有的属性和方法一定要加this使用</li><li>类里的this指向问题</li></ol><ul><li>构造函数中的this指向被创建的实例</li><li>方法里面的this指向这个方法的调用者(比如this.btn.onclic = this.sing，调用者是btn)</li></ul><h5 id="添加节点insertAdjacentHTML："><a href="#添加节点insertAdjacentHTML：" class="headerlink" title="添加节点insertAdjacentHTML："></a><strong>添加节点insertAdjacentHTML：</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.insert<span class="hljs-constructor">AdjacentHTML(<span class="hljs-params">position</span>, <span class="hljs-params">text</span>)</span>;<br></code></pre></td></tr></table></figure><p>position是相对于元素的位置，并且必须是以下字符串之一：</p><ul><li>‘beforebegin’ 元素自身前面</li><li>‘afterbegin’ 插入元素内部的第一个子节点之前</li><li>‘beforeend’ 插入元素内部的最后一个子节点之后</li><li>‘afterend’ 元素自身的后面</li></ul><h3 id="二、构造函数和原型"><a href="#二、构造函数和原型" class="headerlink" title="二、构造函数和原型"></a>二、构造函数和原型</h3><p>ES5中用构造函数和原型来模拟类的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.利用 new Object()创建对象</span><br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-comment">//2.利用对象字面量创建对象</span><br><br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;;<br><br><span class="hljs-comment">//3.利用构造函数创建对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">uname, age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span> = uname;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sing</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sing&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="new在执行时会做的事情："><a href="#new在执行时会做的事情：" class="headerlink" title="new在执行时会做的事情："></a><strong>new在执行时会做的事情：</strong></h5><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法</li><li>返回这个新对象</li></ol><h5 id="实例成员与静态成员"><a href="#实例成员与静态成员" class="headerlink" title="实例成员与静态成员"></a><strong>实例成员与静态成员</strong></h5><ol><li>实例成员就是构造函数内部通过this添加的成员，实例成员只能通过实例化的对象来访问</li><li>静态成员 在构造函数本身上添加的成员吗，只能通过构造函数来访问（不能通过实例）<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Star.sex</span> = <span class="hljs-string">&quot;男&quot;</span><span class="hljs-comment">; //直接加在构造函数上</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="1-构造函数原型对象prototype"><a href="#1-构造函数原型对象prototype" class="headerlink" title="1)构造函数原型对象prototype"></a>1)构造函数原型对象prototype</h4><p>构造函数方法存在浪费内存问题（每个实例的函数都要重新开辟空间）</p><p><img src="https://s2.loli.net/2022/03/15/ZU9qpfJTjog6y4k.png" alt="image.png"></p><p>构造函数通过原型分配的函数是所有对象共享的。</p><p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p>我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Star.prototype.sing = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;sing&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，公共属性定义到构造函数里面，公共方法放到原型对象身上</p><h5 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto___"></a><strong>对象原型__proto___</strong></h5><p>对象身上系统自己添加一个__proto__指向我们构造函数的原型对象prototype</p><ul><li>__proto__和prototype是等价的</li><li>__proto__对象原型的意义在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它知识内部指向原型对象prototype</li></ul><h5 id="原型constructor构造函数"><a href="#原型constructor构造函数" class="headerlink" title="原型constructor构造函数"></a><strong>原型constructor构造函数</strong></h5><p>对象原型(<strong>proto</strong>)和构造函数(prototype)原型对象里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。</p><p>constructor主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><p>如果直接给原型对象赋值，会覆盖掉原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Star</span>,<br>    <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <br>    &#125;,<br>    <span class="hljs-attr">movie</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><strong>原型链</strong></h5><ol><li>Star原型对象里面的__proto__指向Object的原型</li><li>Object对象的__proto__指向null</li></ol><p><img src="https://s2.loli.net/2022/03/15/JRNEFmH4lUOvZiQ.png" alt="image.png"></p><h5 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a><strong>原型对象this指向</strong></h5><ol><li>在构造函数中，里面this指向的是对象实例</li><li>原型对象函数里面的this 指向的也是对象实例</li></ol><h5 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a><strong>扩展内置对象</strong></h5><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">sum</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; this.<span class="hljs-built_in">length</span>; i++)&#123;<br>        <span class="hljs-built_in">sum</span> += this[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）继承"><a href="#2）继承" class="headerlink" title="2）继承"></a><strong>2）继承</strong></h4><h5 id="call-函数"><a href="#call-函数" class="headerlink" title="call()函数"></a><strong>call()函数</strong></h5><p>调用这个函数，并且修改函数运行时的this指向</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">fun.<span class="hljs-built_in">call</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>thisArg：当前调用函数this的指向对象</li><li>arg1, arg2：传递的其他参数</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//1. call()可以调用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br>fn.call();<br><br><span class="hljs-comment">//2.call() 可以改变这个函数的this指向</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>&#125;<br><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;;<br><br>fn.call(o) <span class="hljs-comment">//打印结果为o对象;</span><br><br><span class="hljs-comment">//3.call()的其他参数用来传参</span><br><br></code></pre></td></tr></table></figure><h5 id="借用父构造函数继承属性"><a href="#借用父构造函数继承属性" class="headerlink" title="借用父构造函数继承属性"></a><strong>借用父构造函数继承属性</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Father(<span class="hljs-params">uname</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-comment">//this指向父构造函数的对象实例</span><br>    this.uname = uname;<br>    this.age = age;<br>&#125;<br><span class="hljs-comment">//2.子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Son(<span class="hljs-params">uname</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-comment">//this指向子构造函数的对象实例</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Father</span>.</span></span>call(this,uname,age);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="利用原型对象继承方法"><a href="#利用原型对象继承方法" class="headerlink" title="利用原型对象继承方法"></a><strong>利用原型对象继承方法</strong></h5><ul><li><p>直接让Son的prototype = father的prototype会导致共用地址，改变son的prototype会导致father一起变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">exam</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">//此时Father的prototype中也出现了exam</span><br></code></pre></td></tr></table></figure></li><li><p>实例化一个Father对象（此时开辟了一个新的空间），再把prototype赋值给Son的prototype，此时内存不共用，不会影响Father的prototype</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Son</span>.proto<span class="hljs-keyword">type</span> = new <span class="hljs-type">Father</span>();<br>//如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的构造函数<br><span class="hljs-type">Son</span>.proto<span class="hljs-keyword">type</span>.constructor = <span class="hljs-type">Son</span>;<br><br><span class="hljs-type">Son</span>.proto<span class="hljs-keyword">type</span>.exam = function()&#123;&#125; //此时father的prototype不会产生问题<br></code></pre></td></tr></table></figure></li></ul><h5 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a><strong>类的本质</strong></h5><p>ES6之前通过构造函数+原型实现面向对象编程</p><p>ES6通过类实现面向对象编程</p><p>1.类的本质其实还是一个函数，我们可以简单的认为类就是构造函数的另一种写法</p><ul><li>类有原型对象prototype</li><li>类原型对象prototype里面有ocnstructor指向类本身</li><li>类可以通过原型对象添加方法</li><li>ES6的类其实就是语法糖（两种方法可以实现同样的功能，但是另一种写法更清晰、方便就是语法糖）<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">class Star&#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> Star); <span class="hljs-comment">//打印出function</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3）ES5中的新增方法"><a href="#3）ES5中的新增方法" class="headerlink" title="3）ES5中的新增方法"></a><strong>3）ES5中的新增方法</strong></h4><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h5><p>迭代（遍历）方法：forEach()、map()、filter()、some()、every();</p><h6 id="1-forEach-遍历"><a href="#1-forEach-遍历" class="headerlink" title="1. forEach() 遍历"></a>1. forEach() 遍历</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">array</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">currentValue</span>, <span class="hljs-params">index</span>, <span class="hljs-params">arr</span>)</span>)<br></code></pre></td></tr></table></figure><ul><li>currentValue：数组当前项的值</li><li>index：数组当强项的索引</li><li>arr：数组对象本身</li><li>return无法终止</li></ul><h6 id="2-map-遍历"><a href="#2-map-遍历" class="headerlink" title="2. map() 遍历"></a>2. map() 遍历</h6><ul><li>使用方法与forEach()一致</li><li>区别在于map()返回一个新数组<h6 id="3-filter-筛选"><a href="#3-filter-筛选" class="headerlink" title="3. filter() 筛选"></a>3. filter() 筛选</h6><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">array</span>.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>))<br></code></pre></td></tr></table></figure></li><li>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组</li><li>参数与forEach一样<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-params"><span class="hljs-keyword">function</span>(value,index)</span>)&#123;<br>    <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="3-some-查找是否有满足条件的元素"><a href="#3-some-查找是否有满足条件的元素" class="headerlink" title="3. some() 查找是否有满足条件的元素"></a>3. some() 查找是否有满足条件的元素</h6><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">array</span>.some(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>)</span><br></code></pre></td></tr></table></figure><ul><li>用于检测数组中的元素是否满足指定条件，通俗点讲是查找数组中是否有满足条件的元素</li><li>注意它的返回值是布尔值，如果查找到这个元素就返回true，如果查不到就返回false</li><li>如果找到第一个满足条件的元素，则终止循环，不再继续查找（一真即真，全假才假）</li><li>参数与forEach一致</li><li>遇到return ture就会终止遍历，查找单一元素效率更高</li></ul><h6 id="4-every"><a href="#4-every" class="headerlink" title="4. every()"></a>4. every()</h6><ul><li>使用方法与some()一致</li><li>区别在于一假即假，全真才真</li></ul><h5 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h5><p>去除字符串左右两侧的空格（字符中间的空格不会去除）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;   an  dy    &#x27;</span>;<br><span class="hljs-keyword">var</span> str1 = str.<span class="hljs-built_in">trim</span>();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str1); <span class="hljs-comment">//打印&#x27;an  dy&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="Object-defineProperty-方法"><a href="#Object-defineProperty-方法" class="headerlink" title="Object.defineProperty()方法"></a>Object.defineProperty()方法</h5><p>Object.defineProperty()方法定义对象中新属性或修改原有的属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">obj</span>, <span class="hljs-params">prop</span>, <span class="hljs-params">descriptor</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>obj：必需，目标对象</li><li>prop：必需，需定义或修改的属性的名字</li><li>descriptor：必需，目标属性所拥有的特性</li></ul><p><strong>descriptor说明：以{}对象的形式书写</strong></p><ul><li>value：设置属性的值，默认为undefined</li><li>writable：值是否可以重写，true | false， 默认为false</li><li>enumerable：目标属性是否可以被枚举，true | false， 默认为false</li><li>configurable：目标属性是否可以被删除或是否可以再次修改特性，true | false，默认为false</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> 1,</span><br><span class="hljs-string">    pname</span>: <span class="hljs-string">&#x27;小米&#x27;</span>,<br>    <span class="hljs-attribute">price</span>: <span class="hljs-number">1999</span><br>&#125;;<br><br><span class="hljs-comment">//新增一个Num</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;num&#x27;</span>,&#123;<br>    <span class="hljs-attribute">value</span>: <span class="hljs-number">1000</span><br>&#125;);<br><br><span class="hljs-comment">//修改price</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;price&#x27;</span>,&#123;<br>    <span class="hljs-attribute">value</span>: <span class="hljs-number">1000</span><br>&#125;);<br><br><span class="hljs-comment">//writable 不允许修改重写</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;id&#x27;</span>,&#123;<br>    <span class="hljs-attribute">writable</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">//不允许修改id</span><br>&#125;);<br><br><span class="hljs-comment">//enumerable 不允许被遍历</span><br><span class="hljs-comment">//configurable 不允许修改属性</span><br></code></pre></td></tr></table></figure><h3 id="三、函数进阶"><a href="#三、函数进阶" class="headerlink" title="三、函数进阶"></a>三、函数进阶</h3><h4 id="1-函数的定义和调用"><a href="#1-函数的定义和调用" class="headerlink" title="1)函数的定义和调用"></a>1)函数的定义和调用</h4><h5 id="函数的定义方法："><a href="#函数的定义方法：" class="headerlink" title="函数的定义方法："></a>函数的定义方法：</h5><ol><li>函数声明方式，function关键字（命名函数）<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span><span class="hljs-params">()</span>&#123;&#125;;<br></code></pre></td></tr></table></figure></li><li>函数表达式（匿名函数）<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>new Function(‘参数1’,’参数2’,’函数体’);</li></ol><ul><li>Function里面必须是字符串格式</li><li>执行效率低也不方便书写，较少使用</li><li>所有函数都是Function的实例(对象)<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Function</span><span class="hljs-params">(<span class="hljs-string">&#x27;console.log(123)&#x27;</span>)</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Function</span><span class="hljs-params">(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;console.log(a + b)&#x27;</span>)</span>;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/03/16/vcfQWHp3iDsoyAk.png" alt="image.png"></li></ul><h5 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h5><h6 id="1-普通函数"><a href="#1-普通函数" class="headerlink" title="1.普通函数"></a>1.普通函数</h6><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">fn</span>()&#123;&#125;;<br><span class="hljs-built_in">fn</span>();<br>fn<span class="hljs-selector-class">.call</span>();<br></code></pre></td></tr></table></figure><h6 id="2-对象的方法"><a href="#2-对象的方法" class="headerlink" title="2.对象的方法"></a>2.对象的方法</h6><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> o = &#123;<br>    sayHi: <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br>o.saiHi()<br></code></pre></td></tr></table></figure><h6 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h6><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span><span class="hljs-params">()</span>&#123;&#125;;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star();<br></code></pre></td></tr></table></figure><h6 id="4-绑定事件函数"><a href="#4-绑定事件函数" class="headerlink" title="4.绑定事件函数"></a>4.绑定事件函数</h6><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">btn.onclick = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;&#125;; <span class="hljs-comment">//点击按钮就可以调用</span><br></code></pre></td></tr></table></figure><h6 id="5-定时器函数"><a href="#5-定时器函数" class="headerlink" title="5.定时器函数"></a>5.定时器函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;, <span class="hljs-number">1000</span>); <span class="hljs-comment">//定时器每一秒自动调用一次</span><br></code></pre></td></tr></table></figure><h6 id="6-立即执行函数"><a href="#6-立即执行函数" class="headerlink" title="6.立即执行函数"></a>6.立即执行函数</h6><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    </span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span>)<span class="hljs-params">()</span>;</span> <span class="hljs-comment">//后面加个括号直接调用</span><br></code></pre></td></tr></table></figure><h4 id="2-this"><a href="#2-this" class="headerlink" title="2)this"></a>2)this</h4><h5 id="1-this指向问题"><a href="#1-this指向问题" class="headerlink" title="1.this指向问题"></a>1.this指向问题</h5><p><strong>总结：谁调用指向谁</strong><br>| 调用方法     | this指向                                        | 说明                                           |<br>| ———— | ———————————————– | ———————————————- |<br>| 普通函数     | window                                          | 因为完整写法是window.fn()，调用者是window      |<br>| 对象的方法   | 该方法所属对象(o)                               | 对象调用                                       |<br>| 构造函数     | 实例对象(ldh)，原型对象里面的方法也指向实例对象 | 实例调用                                       |<br>| 绑定事件函数 | 绑定事件对象(btn)                               | 绑定事件的对象触发时调用                       |<br>| 定时器函数   | window                                          | 完整写法是window.setInterval()，调用者是window |<br>| 立即执行函数 | window                                          | 同1普通函数                                    |</p><h5 id="2-改变this的指向"><a href="#2-改变this的指向" class="headerlink" title="2.改变this的指向"></a>2.改变this的指向</h5><p><strong>三种方法：call()、apply()、bind()</strong></p><p><strong>1.call()</strong></p><ul><li>call第一个可以调用函数，第二个可以改变函数内的this指向</li><li>call的主要作用可以实现继承</li></ul><p><strong>2.apply()方法</strong></p><p>apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变函数的this指向</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">fun</span>.<span class="hljs-built_in">apply</span>(thisArg,[argsAraay])<br></code></pre></td></tr></table></figure><ul><li>thisArg：在fun函数运行时指定的this值</li><li>argsArray：传递的值，必须包含在数组里</li><li>返回值就是函数的返回值，因为它是调用函数</li></ul><p>apply的主要应用，比如说我们可以利用apply借助于数学内置对象求最大值</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>.<span class="hljs-built_in">apply</span>(Math, arr)<br></code></pre></td></tr></table></figure><p><strong>3.bind()方法</strong></p><p>bind()方法不会调用函数，但是能改变函数内部this的指向</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">fun</span>.bind(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>thisArg：在fun函数运行时指定的this值</li><li>arg1, arg2：传递的其他参数</li><li>返回由指定的this值和初始化参数改造的原函数拷贝<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a + b);<br>&#125;<br><span class="hljs-keyword">var</span> f = fn.bind(o, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>f();<br></code></pre></td></tr></table></figure>如果有的函数我们不需要立即调用，但是又想改变这个函数内部的this指向此时用bind。</li></ul><p>比如我们有一个按钮，当我们点击之后就禁用这个按钮，3秒钟之后开启这个按钮</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//错误例</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">//这里不能写this，因为这里this指向window</span><br>        <br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;<br><br><span class="hljs-comment">//正确例</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">//这里不能写this，因为这里this指向window</span><br>        <br>    &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-number">3000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当函数里的this还需要使用，不能改变时，可以用bind(本身，this)的方法把this以传参的方式传进函数</p><p><strong>call apply bind的异同点</strong></p><p><strong>相同点：</strong><br>都可以改变函数内部的this指向</p><p><strong>区别点：</strong></p><ol><li>call和apply会调用函数，并且改变函数内部this指向</li><li>call和apply传递的参数不一样，call传递参数aru1, aru2…形式，apply必须用数组形式[arg]</li><li>bind不会调用函数，可以改变函数内部this指向</li></ol><p><strong>主要应用场景：</strong></p><ol><li>call经常做继承</li><li>apply经常跟数组有关系，比如借助于数学对象实现数组的最大值最小值</li><li>bind不调用函数，但是还想改变this指向，比如改变定时器内部的this指向</li></ol><h4 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3)严格模式"></a>3)严格模式</h4><h5 id="1-什么是严格模式"><a href="#1-什么是严格模式" class="headerlink" title="1.什么是严格模式"></a>1.什么是严格模式</h5><p>JavaScript除了提供正常模式意外，还提供了严格模式(strict mode)。ES5的严格模式是采用具有限制性JavaScript变体的一种方法，即在严格的条件下运行JS代码。</p><ol><li>消除了JS语法的一些不合理、不严谨之处，减少了一些怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li><li>提高编译器效率，增加运行速度</li><li>金庸了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫，不如一些保留字如:class,enum,export,extends,import,super不能做变量名</li></ol><h5 id="2-开启严格模式"><a href="#2-开启严格模式" class="headerlink" title="2.开启严格模式"></a>2.开启严格模式</h5><p>严格模式可以应用到整个脚本或个别函数中。</p><p><strong>为整个脚本开启严格模式’use strict’</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-javascript">    &#x27;use strict&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">//下面的代码就会按照严格模式执行代码</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有的script基本是严格模式，有的是正常模式，这样直接写不利于文件合并，所以可以把整个脚本文件放在一个立即执行的匿名函数（其实就相当于main函数）之中，这样独立创建一个作用域而不影响其他script脚本文件。(){</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-string">&quot;use strict&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">//再写代码</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    )();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>为某个函数开启严格模式’use strict’</strong><br>直接写在函数第一句就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-comment">//再写代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-严格模式的变化"><a href="#3-严格模式的变化" class="headerlink" title="3.严格模式的变化"></a>3.严格模式的变化</h5><h6 id="1-变量规定"><a href="#1-变量规定" class="headerlink" title="1.变量规定"></a>1.变量规定</h6><ul><li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量，严格模式禁止这种用法，变量必须先用var声明然后再使用</li><li>严禁删除已经声明好的变量, delete var;</li></ul><h6 id="2-this指向"><a href="#2-this指向" class="headerlink" title="2.this指向"></a>2.this指向</h6><ul><li>正常模式下全局作用域函数中的this指向window对象</li><li>严格模式下全局作用域函数中的this是undefined </li><li>严格模式下，如果构造函数不加new调用，this会报错</li><li>new实例化的构造函数指向创建的对象实例</li><li>定时器this还是指向window</li><li>事件、对象还是指向调用者</li></ul><h6 id="3-函数变化"><a href="#3-函数变化" class="headerlink" title="3.函数变化"></a>3.函数变化</h6><ul><li>严格模式下函数里面的参数不允许有重名</li><li>函数必须声明在顶层，不允许在非函数的代码块内声明函数（可以在function里写function，不可以在if、for等里面写）</li></ul><h4 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4)高阶函数"></a>4)高阶函数</h4><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//对其他函数进行操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">callback</span>)&#123;<br>    callback&amp;&amp;<span class="hljs-title function_">callback</span>();<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)&#125;)<br><br><span class="hljs-comment">//将函数作为返回值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>函数也是一种数据类型，同样可以作为参数，传递给另一个参数使用，最典型的就是作为回调函数</p><h4 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5)闭包"></a>5)闭包</h4><h5 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1.什么是闭包"></a>1.什么是闭包</h5><p>闭包(closure)指有权访问另一个函数作用域中变量的函数。</p><p>简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//闭包：fun这个函数的作用域访问了另外一个函数fn里面的局部变量num</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>    &#125;<br>    <span class="hljs-title function_">fun</span>()<br>&#125;<br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><h5 id="2-闭包的作用"><a href="#2-闭包的作用" class="headerlink" title="2.闭包的作用"></a>2.闭包的作用</h5><p>闭包的主要作用：延申了变量的作用范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fun;<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn</span>(); <br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">//拿到了fn里面的值，创造了一个闭包</span><br><span class="hljs-comment">//相当于 var f = fun()&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>简单写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-闭包的案例"><a href="#3-闭包的案例" class="headerlink" title="3.闭包的案例"></a>3.闭包的案例</h5><p><strong>点击li输出当前li的索引号</strong><br>1.利用动态添加属性的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>).<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;<br>    lis[i].<span class="hljs-property">index</span> = i;<br>    lis[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">//异步任务，如果调用i的话就全是lis.length</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.利用闭包的方式得到当前小li的索引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>).<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;<br>    <span class="hljs-comment">//利用for循环创建了4个立即执行函数</span><br>    <span class="hljs-comment">//立即执行函数也称为小闭包，因为立即执行函数里面的任何一个函数都可以使用它的i变量</span><br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)&#123;<br>        lis[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>        &#125;<br>    &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3秒钟之后，打印所有li元素的内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//错误例</span><br><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>).<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lis[i].<span class="hljs-property">innerHTML</span>); <span class="hljs-comment">//异步任务，先执行for再执行这个任务，打印出来全是lis.length</span><br>               &#125;,<span class="hljs-number">3000</span>)<br>&#125;<br><span class="hljs-comment">//正确例</span><br><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>).<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lis[i].<span class="hljs-property">innerHTML</span>); <span class="hljs-comment">//异步任务，先执行for再执行这个任务，打印出来全是lis.length</span><br>               &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-递归"><a href="#6-递归" class="headerlink" title="6)递归"></a>6)递归</h4><p>如果一个函数在内部自己调用自己，这个函数就是递归函数</p><h5 id="1-浅拷贝和深拷贝"><a href="#1-浅拷贝和深拷贝" class="headerlink" title="1.浅拷贝和深拷贝"></a>1.浅拷贝和深拷贝</h5><ol><li>浅拷贝只是拷贝一层，更深层次对象级别只拷贝引用（内存地址）</li><li>深拷贝拷贝多层，每一级别的数据都会拷贝</li><li>Object. Assign(target,…sources) es6新增方法可以浅拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//待拷贝对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;andy&#x27;</span>,<br>    <span class="hljs-attr">msg</span>:&#123;<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> o = &#123;&#125;;<br><span class="hljs-comment">//封装函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newobj, oldobj</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> oldobj)&#123;<br>        <span class="hljs-comment">//判断属性值属于哪种数据类型</span><br>        <span class="hljs-comment">//1.获取属性值 oldobj[k]</span><br>        <span class="hljs-keyword">var</span> item = oldobj[k];<br>        <span class="hljs-comment">//2.判断这个值是否是数组</span><br>        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)&#123;<br>            newobj[k] = [];<br>            <span class="hljs-title function_">deepCopy</span>(newobj,item) <span class="hljs-comment">//递归</span><br>            <span class="hljs-comment">//3.判断这个值是否是对象</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item intanceof <span class="hljs-title class_">Object</span>)&#123;<br>            newobj[k] = &#123;&#125;;<br>            <span class="hljs-title function_">deepCopy</span>(newobj[k], item)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//4.属于简单数据类型</span><br>            newobj[k] = item;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">deepCopy</span>(o,obj);<br></code></pre></td></tr></table></figure><h3 id="四、正则表达式"><a href="#四、正则表达式" class="headerlink" title="四、正则表达式"></a>四、正则表达式</h3><p>正则表达式(Regular Expression)是用于匹配字符串中字符组合的模式。在JavaScript总，正则表达式也是对象。</p><h4 id="1）正则表达式在JS中的应用"><a href="#1）正则表达式在JS中的应用" class="headerlink" title="1）正则表达式在JS中的应用"></a>1）正则表达式在JS中的应用</h4><h5 id="1-创建正则表达式"><a href="#1-创建正则表达式" class="headerlink" title="1.创建正则表达式"></a>1.创建正则表达式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.利用RegExp对象来创建</span><br><span class="hljs-keyword">var</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-regexp">/123/</span>);<br><span class="hljs-comment">//2.利用字面量来创建</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/123/</span>;<br></code></pre></td></tr></table></figure><h5 id="2-测试正则表达式test"><a href="#2-测试正则表达式test" class="headerlink" title="2.测试正则表达式test"></a>2.测试正则表达式test</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">regexObj.<span class="hljs-title function_">test</span>(str)<br></code></pre></td></tr></table></figure><ol><li>regexObj是写的正则表达式</li><li>str是我们要测试的文本</li><li>就是检测str是否符合我们写的正则表达式规范，返回true | false</li></ol><h4 id="2-正则表达式中的特殊字符"><a href="#2-正则表达式中的特殊字符" class="headerlink" title="2)正则表达式中的特殊字符"></a>2)正则表达式中的特殊字符</h4><h4 id="1-边界符"><a href="#1-边界符" class="headerlink" title="1.边界符"></a>1.边界符</h4><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本(以谁开始)</td></tr><tr><td>$</td><td>表示匹配行尾的文本(以谁结束)</td></tr></tbody></table><h4 id="2-字符类"><a href="#2-字符类" class="headerlink" title="2.字符类"></a>2.字符类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//[]表示其中一系列可供选择，只要匹配一个就可以了</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/[abc]/</span>; <span class="hljs-comment">//包含abc中的任意一个</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/^[abc]$/</span>; <span class="hljs-comment">//只能&#x27;a&#x27;或&#x27;b&#x27;或&#x27;c&#x27;单个字符才行</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/^[a-z]$/</span>; <span class="hljs-comment">//只能a-z任意一个单个字符</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/^[a-zA-Z]$/</span>; <span class="hljs-comment">//26个字母无论大小写都可以</span><br><span class="hljs-comment">//[]里面的^表示取反(不能包含这些)</span><br><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/^[^a-z]&amp;/</span>; <span class="hljs-comment">//不能是a-z任意一个单一字符</span><br></code></pre></td></tr></table></figure><h4 id="3-量词符"><a href="#3-量词符" class="headerlink" title="3.量词符"></a>3.量词符</h4><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>&gt;=0  重复零次或多次</td></tr><tr><td>+</td><td>&gt;=1  重复一次或多次</td></tr><tr><td>?</td><td>[0,1]  重复零次或一次</td></tr><tr><td>{n}</td><td>=n  重复n次</td></tr><tr><td>{n,}</td><td>[n,]  重复n次或更多次</td></tr><tr><td>{n,m}</td><td>[n,m]  重复n到m次</td></tr></tbody></table><h4 id="4-括号总结"><a href="#4-括号总结" class="headerlink" title="4.括号总结"></a>4.括号总结</h4><ol><li>{ } 大括号 量词符，表示重复次数</li><li><input disabled="" type="checkbox"> 中括号  字符集合 匹配方括号中的任意字符</li><li>( ) 小括号 表示优先级(类似算术优先级,括号里当一个整体)</li></ol><h4 id="5-预定义类"><a href="#5-预定义类" class="headerlink" title="5.预定义类"></a>5.预定义类</h4><table><thead><tr><th>预定类</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配0-9之间的任一数字，相当于[0-9]</td></tr><tr><td>\D</td><td>匹配0-9意外的字符，相当于[^0-9]</td></tr><tr><td>\w</td><td>匹配任意字母、数字和下划线，相当于[A-Za-z0-9_]</td></tr><tr><td>\W</td><td>匹配所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]</td></tr><tr><td>\s</td><td>匹配空格(包括换行符、制表符、空格符等)，相等于[\t\r\n\b\f]</td></tr><tr><td>\S</td><td>匹配非空格字符，相当于[^\t\r\n\b\f]</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//座机号码验证：全国座机号码 两种格式：010-12345678 0530-1234567</span><br><span class="hljs-comment">//正则里|表示或者</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\d&#123;3&#125;-\d&#123;8&#125; | \d&#123;4&#125;-\d&#123;7&#125;$/</span><br></code></pre></td></tr></table></figure><h4 id="3-正则表达式中的替换"><a href="#3-正则表达式中的替换" class="headerlink" title="3)正则表达式中的替换"></a>3)正则表达式中的替换</h4><h5 id="1-替换replace"><a href="#1-替换replace" class="headerlink" title="1.替换replace"></a>1.替换replace</h5><p>replace()方法可以实现替换字符操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">stringObject.<span class="hljs-title function_">replace</span>(regexp/substr,replacement)<br></code></pre></td></tr></table></figure><p>返回值是替换完毕的新字符串。</p><h6 id="2-正则表达式参数"><a href="#2-正则表达式参数" class="headerlink" title="2.正则表达式参数"></a>2.正则表达式参数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/表达式/[<span class="hljs-keyword">switch</span>]<br></code></pre></td></tr></table></figure><p>switch(也称修饰符)按照什么样的模式来匹配，有三种值：</p><ul><li>g：全局匹配</li><li>i：忽略大小写</li><li>gi：全局匹配+忽略大小写</li></ul><h3 id="五、ES6"><a href="#五、ES6" class="headerlink" title="五、ES6"></a>五、ES6</h3><h4 id="1-let"><a href="#1-let" class="headerlink" title="1)let"></a>1)let</h4><p>ES6中新增的用于声明变量的关键字。</p><ul><li>let声明的变量只在所处于的块级有效（花括号{}里，如if、for等，var没用块级作用域）</li><li>不存在变量提升（必须先声明再使用）</li><li>具有暂时性死区（一旦在块级作用域内声明了变量，外部的同名变量就没法在块级内访问）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//循环里var与let的区别</span><br><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>    arr[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>arr[<span class="hljs-number">0</span>]();<br>arr[<span class="hljs-number">1</span>]();<br><span class="hljs-comment">//输出都是2</span><br><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>    arr[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>arr[<span class="hljs-number">0</span>](); <span class="hljs-comment">//输出0</span><br>arr[<span class="hljs-number">1</span>](); <span class="hljs-comment">//输出1</span><br></code></pre></td></tr></table></figure><h4 id="2-const"><a href="#2-const" class="headerlink" title="2)const"></a>2)const</h4><ul><li>具有块级作用域</li><li>声明常量必须赋初始值</li><li>常量赋值后，值不能修改（但是复杂类型内部的值可以更改，但是不可以赋值）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ary = [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>];<br>ary[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>; <span class="hljs-comment">//这个操作可以</span><br>ary = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]; <span class="hljs-comment">//这个不可以</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>函数级作用域</td><td>块级作用域</td><td>块级作用域</td></tr><tr><td>变量提升</td><td>不存在变量提升</td><td>不存在变量提升</td></tr><tr><td>值可更改</td><td>值可更改</td><td>值不可更改</td></tr></tbody></table><h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3)解构赋值"></a>3)解构赋值</h4><p><strong>数组解构</strong></p><p>数组结构允许我们按照一一对应的关系从数组中取值然后将值赋值给变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a,b,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br></code></pre></td></tr></table></figure><p>如果解构不成功，变量的值为undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo] = [];<br><span class="hljs-keyword">let</span> [bar, foo] = [<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p><strong>对象解构</strong></p><p>按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。</p><p>1.名字一样的解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<br><span class="hljs-keyword">let</span>&#123;name, age&#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br></code></pre></td></tr></table></figure><p>2.名字不一样的解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span>&#123; <span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myAge);<br></code></pre></td></tr></table></figure><h4 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4)箭头函数"></a>4)箭头函数</h4><p>ES6中新增的定义函数的方法，用来简化函数定义的语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1,num2</span>)&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><span class="hljs-comment">//箭头函数方法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2</span>) =&gt; num1 + num2;<br></code></pre></td></tr></table></figure><p>如果形参只有一个，可以省略小括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">v</span>)&#123;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-comment">//箭头函数方法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = v =&gt; v;<br></code></pre></td></tr></table></figure><p><strong>this指向问题</strong></p><p>箭头函数不绑定this关键字，箭头函数中的this指向函数定义位置上下文的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//因为定义在fn中，所以this和fn的this指向一致</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">20</span>,<br>    <span class="hljs-attr">say</span>:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>); <span class="hljs-comment">//undefined，因为定义在var里，相当于全局作用域，this绑定给了window</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-剩余参数"><a href="#5-剩余参数" class="headerlink" title="5)剩余参数"></a>5)剩余参数</h4><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。(箭头函数里不能用argments)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    args.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> total += item;) <span class="hljs-comment">//item就是每一个参数</span><br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>剩余参数与解构配合使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stutends = [<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>];<br><span class="hljs-keyword">let</span> [s1,...s2] = ary1<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1); <span class="hljs-comment">//wangwu</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2); <span class="hljs-comment">//zhangsan, lisi</span><br></code></pre></td></tr></table></figure><h4 id="6）Array的扩展方法"><a href="#6）Array的扩展方法" class="headerlink" title="6）Array的扩展方法"></a>6）Array的扩展方法</h4><p><strong>扩展运算符（展开语法）</strong></p><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>...ary <span class="hljs-comment">//1,2,3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...ary); <span class="hljs-comment">//1 2 3 逗号被当作参数分隔符</span><br></code></pre></td></tr></table></figure><p>扩展运算符可以用作合并数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">let</span> ary1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> ary2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">let</span> ary3 = [...ary1, ...ary2];<br><span class="hljs-comment">//方法二</span><br>ary1.<span class="hljs-title function_">push</span>(...ary2);<br></code></pre></td></tr></table></figure><p>将伪数组转化为真数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> oDivs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">queryAllSelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>oDivs = [...oDivs];<br></code></pre></td></tr></table></figure><p><strong>构造函数方法：Array.from()</strong></p><p>将类数组或可遍历对象转换为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-attr">length</span>:<span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike); <span class="hljs-comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;1&quot;</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;length&quot;</span>:<span class="hljs-number">2</span><br>&#125;<br>ley newAry = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(aryLike, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span> );<br></code></pre></td></tr></table></figure><p><strong>实例方法：find()</strong></p><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [&#123;<br>    <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;,&#123;<br>    <span class="hljs-attr">id</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;];<br><span class="hljs-keyword">let</span> target = ary.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> item.<span class="hljs-property">id</span> == <span class="hljs-number">2</span>); <span class="hljs-comment">//item是里面的值，index是索引</span><br></code></pre></td></tr></table></figure><p><strong>实例方法：findIndex()</strong></p><p>找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> index = ary.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">value,index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p><strong>实例方法：includes()</strong></p><p>表示某个数组是否包含给定的值，返回布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="7-String的扩展方法"><a href="#7-String的扩展方法" class="headerlink" title="7)String的扩展方法"></a>7)String的扩展方法</h4><p><strong>模板字符串</strong></p><p>ES6新增的创建字符串的方式，使用反引号定义。</p><p>模板字符串中可以解析变量。(格式化输出)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>; <span class="hljs-comment">//tab上面的键，波浪键</span><br>ley sayHello = <span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p>模板字符串中可以换行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangssan&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> html = <span class="hljs-string">`</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;result.name&#125;</span></span><br><span class="hljs-string"><span class="hljs-subst">$&#123;result.age&#125;</span></span><br><span class="hljs-string"><span class="hljs-subst">$&#123;result.sex</span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-string">`;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">/*</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"></span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        zhangssan</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        20</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        男</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">    </span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">*/</span></span></span><br></code></pre></td></tr></table></figure><p>模板字符串可以调用函数(调用方法跟输出变量是一样的)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&#x27;返回值&#x27;</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">`<span class="hljs-subst">$&#123;fn()&#125;</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">//返回值</span><br></code></pre></td></tr></table></figure><p><strong>实例方法：startsWith()和endsWith()</strong></p><ul><li>startsWith():表示字符串是否在原字符串头部，返回布尔值</li><li>endsWith():表示字符串是否在原字符串头部，返回布尔值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello worlds!&#x27;</span>;<br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">//true</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>实例方法：repeat()</strong></p><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><h4 id="8-Set数据结构"><a href="#8-Set数据结构" class="headerlink" title="8)Set数据结构"></a>8)Set数据结构</h4><p>ES6提供了新的数据解构Srt，它类似于数组，但是成员的值都是唯一的，没有重复的值(相当于HashSet)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-comment">//可以接收数组作为参数</span><br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]);<br>s.<span class="hljs-title function_">size</span>()<span class="hljs-comment">//大小</span><br></code></pre></td></tr></table></figure><p><strong>实例方法</strong></p><ul><li>add(value)：添加某个值，返回Set结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为Set的成员</li><li>clear()：清楚所有成员，没有返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//添加</span><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">//删除</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//查找</span><br>s.<span class="hljs-title function_">clear</span>(); <span class="hljs-comment">//清楚</span><br></code></pre></td></tr></table></figure><p><strong>遍历</strong></p><p>Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Web APIs</title>
    <link href="/blog/2022/03/14/JavaScript-Web-APIs/"/>
    <url>/blog/2022/03/14/JavaScript-Web-APIs/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Web-APIs和JS基础关联性"><a href="#1、Web-APIs和JS基础关联性" class="headerlink" title="1、Web APIs和JS基础关联性"></a>1、Web APIs和JS基础关联性</h3><p><img src="https://s2.loli.net/2022/03/13/oeXrYqQSZn7JG5C.png" alt="image.png"></p><h3 id="2、DOM"><a href="#2、DOM" class="headerlink" title="2、DOM"></a>2、DOM</h3><p>文档对象模型(Document Object Model)，处理HTML或者XML的标准编程接口</p><h4 id="1-DOM树"><a href="#1-DOM树" class="headerlink" title="1) DOM树"></a><strong>1) DOM树</strong></h4><p><img src="https://s2.loli.net/2022/03/13/vcRpSgHd4zlAJex.png" alt="image.png"></p><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>元素：页面中所有的标签都是元素，DOM中使用elment表示</li><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</li></ul><h5 id="DOM把以上内容都看作是对象"><a href="#DOM把以上内容都看作是对象" class="headerlink" title="DOM把以上内容都看作是对象"></a><strong>DOM把以上内容都看作是对象</strong></h5><h4 id="2-获取元素"><a href="#2-获取元素" class="headerlink" title="2) 获取元素"></a><strong>2) 获取元素</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1、根据ID获取getElementById()</span><br>&lt;div id=<span class="hljs-string">&#x27;time&#x27;</span>&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">9</span>-<span class="hljs-number">9</span>&lt;/div&gt;<br><br><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;time&#x27;</span>); <span class="hljs-comment">//返回的是单个元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element)<br><br><span class="hljs-comment">//console.dir()打印返回的元素对象，dir是目录的意思</span><br><br><span class="hljs-comment">//2、根据标签名获取getElementsByTageName()</span><br><span class="hljs-comment">//返回的是元素对象的集合，以伪数组的形式存储的</span><br><span class="hljs-keyword">var</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTageName</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lis[<span class="hljs-number">0</span>])<br><br><br><span class="hljs-comment">//3、指定父元素再获取子元素element.getElementsByTageName(&#x27;标签名&#x27;);</span><br>&lt;ol&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li1<span class="hljs-tag">&lt;/<span class="hljs-name">lis</span>&gt;</span></span><br>&lt;/ol&gt;<br><br><span class="hljs-keyword">var</span> ol = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;ol&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ol[<span class="hljs-number">0</span>].<span class="hljs-title function_">getElementsByTageName</span>(<span class="hljs-string">&#x27;li&#x27;</span>)); <span class="hljs-comment">//记得是伪数组里的第0个</span><br></code></pre></td></tr></table></figure><h5 id="H5新增获取元素"><a href="#H5新增获取元素" class="headerlink" title="H5新增获取元素"></a><strong>H5新增获取元素</strong></h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1、getElementsByClassName() 根据类名获取</span><br><span class="hljs-comment">//2、querySelector()返回指定选择器的第一个元素对象</span><br><span class="hljs-keyword">var</span> firstBox = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>); <span class="hljs-comment">//.是类选择器</span><br><span class="hljs-keyword">var</span> firstBox = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#box&#x27;</span>); <span class="hljs-comment">//#是id选择器</span><br><span class="hljs-keyword">var</span> firstBox = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;li&#x27;</span>); <span class="hljs-comment">//标签不用加前缀</span><br><span class="hljs-comment">//3、querySelectorALL() 返回指定选择器的所有元素</span><br><span class="hljs-comment">//性质同querySelector</span><br></code></pre></td></tr></table></figure><h4 id="3-获取特殊元素"><a href="#3-获取特殊元素" class="headerlink" title="3) 获取特殊元素"></a><strong>3) 获取特殊元素</strong></h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//1.获取body元素</span><br><span class="hljs-keyword">var</span> bodyEle = <span class="hljs-built_in">document</span>.body;<br><span class="hljs-comment">//2.获取html元素</span><br><span class="hljs-keyword">var</span> htmlEle = <span class="hljs-built_in">document</span>.documentElement;<br></code></pre></td></tr></table></figure><h4 id="4-事件基础"><a href="#4-事件基础" class="headerlink" title="4) 事件基础"></a><strong>4) 事件基础</strong></h4><p>简单理解：触发–响应机制</p><p>事件由三部分组成：</p><ol><li>事件源：事件被出发的对象</li><li>事件类型：如何触发 什么事件 如鼠标点击(onclick)、鼠标经过</li><li>事件处理程序：通过一个函数赋值的方式完成</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;button&lt;/button&gt;<br><br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>); <span class="hljs-comment">//事件源</span><br><span class="hljs-comment">//事件类型和事件处理程序</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击触发</td></tr><tr><td>onmouseover</td><td>鼠标经过触发</td></tr><tr><td>onmouseout</td><td>鼠标离开触发</td></tr><tr><td>onfocus</td><td>获得鼠标焦点触发</td></tr><tr><td>onblur</td><td>失去鼠标焦点触发</td></tr><tr><td>onmousemove</td><td>鼠标移动触发</td></tr><tr><td>onmouseup</td><td>鼠标弹起触发</td></tr><tr><td>onmousedown</td><td>鼠标按下触发</td></tr></tbody></table><h4 id="5-操作元素"><a href="#5-操作元素" class="headerlink" title="5) 操作元素"></a><strong>5) 操作元素</strong></h4><h5 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a><strong>改变元素内容</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.inner<span class="hljs-constructor">Text()</span><br>div.inner<span class="hljs-constructor">Text(&#x27;&lt;<span class="hljs-params">strong</span>&gt;今天是&lt;<span class="hljs-operator">/</span><span class="hljs-params">strong</span>&gt; 2019&#x27;)</span>；/不识别html标签，非W3C标准<br></code></pre></td></tr></table></figure><p>从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.inner<span class="hljs-constructor">HTML()</span><br>div.inner<span class="hljs-constructor">HTML(&#x27;&lt;<span class="hljs-params">strong</span>&gt;今天是&lt;<span class="hljs-operator">/</span><span class="hljs-params">strong</span>&gt; 2019&#x27;)</span>；/识别html标签，W3C标准<br></code></pre></td></tr></table></figure><p>起始位置到终止位置全部内容，包括html标签，同时保留空格和换行</p><h5 id="改变元素属性"><a href="#改变元素属性" class="headerlink" title="改变元素属性"></a><strong>改变元素属性</strong></h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">zxy.onclick = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>    img.src = <span class="hljs-string">&#x27;images/zxy.jpg&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="表单属性设置"><a href="#表单属性设置" class="headerlink" title="表单属性设置"></a><strong>表单属性设置</strong></h5><p>利用DOM可以操作如下表单元素属性：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span>、value、checked、selected、disabled<br></code></pre></td></tr></table></figure><h5 id="样式属性设置"><a href="#样式属性设置" class="headerlink" title="样式属性设置"></a><strong>样式属性设置</strong></h5><p>可以通过JS修改元素的大小、颜色、位置等样式</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">//1.element.style 行内样式操作</span><br>div.onclick = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;purple&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//2.element.className类名样式操作</span><br>div.onclick = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">this</span>.className = <span class="hljs-string">&#x27;change&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a><strong>排他思想</strong></h5><p>如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循坏的排他思想</p><ol><li>所有元素全部清除样式(干掉其他人)</li><li>给当前元素设置样式(留下我自己)</li></ol><h5 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a><strong>获取元素属性</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.element</span>.属性<br><span class="hljs-number">2</span><span class="hljs-selector-class">.element</span><span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;属性&#x27;</span>) <span class="hljs-comment">//可以获取自定义属性</span><br></code></pre></td></tr></table></figure><h5 id="设置元素属性"><a href="#设置元素属性" class="headerlink" title="设置元素属性"></a><strong>设置元素属性</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.element</span>.属性 = ‘值’<br><span class="hljs-number">2</span><span class="hljs-selector-class">.element</span><span class="hljs-selector-class">.settAttribute</span>(<span class="hljs-string">&#x27;属性&#x27;</span>,‘值’) <span class="hljs-comment">//可以设置自定义属性</span><br></code></pre></td></tr></table></figure><h5 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a><strong>H5自定义属性</strong></h5><ul><li>H5规定自定义属性data-开头作为属性名并且赋值</li></ul><h5 id="获取H5自定义属性"><a href="#获取H5自定义属性" class="headerlink" title="获取H5自定义属性"></a><strong>获取H5自定义属性</strong></h5><ol><li>兼容性获取 element.getAttribute(‘data-index’);</li><li>H5新增element.dataset.index 或者 element.dataset[‘index’]</li><li>如果自定义属性有多个-链接的单词，我们获取的时候采取驼峰命名法</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">div</span> data-list-name=<span class="hljs-string">&#x27;1&#x27;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dataset</span><span class="hljs-selector-class">.listName</span><br>dive<span class="hljs-selector-class">.dataset</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;listName&#x27;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="6-节点操作"><a href="#6-节点操作" class="headerlink" title="6) 节点操作"></a><strong>6) 节点操作</strong></h4><h5 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a><strong>节点概述</strong></h5><p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点 nodeType为1</li><li>属性节点 nodeType为2</li><li>文本节点 nodeType为3(文本节点包含文字、空格、换行等)<br>实际开发中，节点操作主要操作的是元素节点</li></ul><h5 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a><strong>节点层级</strong></h5><p>最常见的是父子兄层级。</p><ol><li>父节点 parentNode</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> code = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.code&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">//得到的是最近的父级节点，找不到则返回null</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> box = code.<span class="hljs-property">parentNode</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>子节点 childNodes、children</li></ol><p>1)childNodes</p><p>获取所有的子节点，包含元素节点、文本节点（换行、空格）等</p><p>如果只想获得里面的元素节点，则需要专门处理，所以不提倡使用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> ul = document.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ul.childNodes.<span class="hljs-built_in">length</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ul.childNodes[i].nodeType == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ul.childNodes[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2)children</p><p>parentNode.children是一个只读属性，返回所有的子元素节点，只返回元素节点，其余节点不返回</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>firstChild</td><td>获取第一个子节点，不管是文本节点还是元素节点</td></tr><tr><td>firstElementChild</td><td>获取第一个子元素节点</td></tr><tr><td>lastChild</td><td>获取最后一个子节点，不管是文本节点还是元素节点</td></tr><tr><td>lastElementChild</td><td>获取最后一个子元素节点</td></tr></tbody></table><ol start="2"><li>兄弟节点 nextSibling</li></ol><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>nextSibling</td><td>下一个兄弟节点，不管是文本节点还是元素节点</td></tr><tr><td>nextElementSibling</td><td>下一个喜兄弟元素节点</td></tr><tr><td>previousSibling</td><td>上一个兄弟节点，不管是文本节点还是元素节点</td></tr><tr><td>previousSibling</td><td>上一个兄弟元素节点</td></tr></tbody></table><h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a><strong>创建节点</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//1.创建元素节点</span><br>var li = document.creat<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span><br><span class="hljs-comment">//2.添加元素节点</span><br>node.append<span class="hljs-constructor">Child(<span class="hljs-params">child</span>)</span><span class="hljs-comment">//追加元素，相当于push</span><br>node.insert<span class="hljs-constructor">Before(<span class="hljs-params">child</span>,指定元素)</span><br></code></pre></td></tr></table></figure><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">node.remove<span class="hljs-constructor">Child(<span class="hljs-params">child</span>)</span><br></code></pre></td></tr></table></figure><p>删除指定子节点，返回值为删除的子节点</p><h5 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a><strong>复制节点</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">node.clone<span class="hljs-constructor">Node()</span><br></code></pre></td></tr></table></figure><ol><li>如果括号参数为空或为false，则为浅拷贝，只复制标签不复制内容</li><li>括号为true则深拷贝，复制内容</li></ol><h5 id="三种创建元素方式区别"><a href="#三种创建元素方式区别" class="headerlink" title="三种创建元素方式区别"></a><strong>三种创建元素方式区别</strong></h5><ol><li>document.write() 创建元素，再调用会导致页面重绘(创建一个新页面，只有write里的内容)</li><li>document.innerHTML 创建多个元素时效率更高（使用数组，不要拼接字符串），结构稍微复杂</li><li>document.creatElement() 创建多个元素效率稍微低一点，但是结构更清晰</li></ol><h3 id="3、事件高级"><a href="#3、事件高级" class="headerlink" title="3、事件高级"></a>3、事件高级</h3><h4 id="1-注册事件"><a href="#1-注册事件" class="headerlink" title="1) 注册事件"></a><strong>1) 注册事件</strong></h4><h5 id="传统注册事件"><a href="#传统注册事件" class="headerlink" title="传统注册事件"></a><strong>传统注册事件</strong></h5><ul><li>利用on开头的事件，如onclick</li><li>特点：注册事件的唯一性（同一个元素同一个事件只能设置一个处理函数）</li></ul><h5 id="方法监听注册方式"><a href="#方法监听注册方式" class="headerlink" title="方法监听注册方式"></a><strong>方法监听注册方式</strong></h5><ul><li>w3c标准</li><li>addEventListener()是一个方法</li><li>IE9之前使用attachEvent()代替</li><li>特点：同一个元素同一个事件可以注册多个事件</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">eventTarget.add<span class="hljs-constructor">EvenrtListener(<span class="hljs-params">type</span>, <span class="hljs-params">listener</span>[,<span class="hljs-params">useCaptrue</span>])</span><br></code></pre></td></tr></table></figure><p>改方法接受三个参数：</p><ul><li>type：事件类型字符串，比如click、mouseover，注意这里不要带on</li><li>listner：事件处理函数，事件发生时，会调用该监听函数</li><li>userCapture：可选参数，是一个布尔值，默认是false</li></ul><h5 id="attachEvent事件监听方式（非标准，不提倡）"><a href="#attachEvent事件监听方式（非标准，不提倡）" class="headerlink" title="attachEvent事件监听方式（非标准，不提倡）"></a><strong>attachEvent事件监听方式（非标准，不提倡）</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">eventTraget.attach<span class="hljs-constructor">Event(<span class="hljs-params">eventNameWithOn</span>, <span class="hljs-params">callback</span>)</span><br></code></pre></td></tr></table></figure><p>该方法接受两个参数：</p><ul><li>eventNameWithOn：事件类型字符串，比如onclick、onmouseover，这里要带on</li><li>callback：事件处理函数，当目标触发事件时回调函数被调用</li></ul><h4 id="2-删除事件"><a href="#2-删除事件" class="headerlink" title="2) 删除事件"></a><strong>2) 删除事件</strong></h4><h5 id="传统方式解绑"><a href="#传统方式解绑" class="headerlink" title="传统方式解绑"></a><strong>传统方式解绑</strong></h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">eventTarget.onclick</span> = null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="方法监听解绑方式"><a href="#方法监听解绑方式" class="headerlink" title="方法监听解绑方式"></a><strong>方法监听解绑方式</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">eventTarget.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">fn</span>)</span>; <span class="hljs-comment">//与添加时写法一致</span><br></code></pre></td></tr></table></figure><h4 id="3-DOM事件流"><a href="#3-DOM事件流" class="headerlink" title="3) DOM事件流"></a><strong>3) DOM事件流</strong></h4><p>事件流描述的是从页面中接收事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p><p>DOM事件流分为3个阶段：</p><ol><li>捕获阶段</li><li>当前目标阶段</li><li>冒泡阶段</li></ol><p>比如我们给一个div注册了点击事件：</p><p><img src="https://s2.loli.net/2022/03/14/kdg4KjUWXEc5HOs.png" alt="image.png"></p><ul><li>dom事件流 三个阶段</li></ul><ol><li>JS代码中只能执行捕获或者冒泡其中的一个阶段</li><li>onclick和attachEvent只能得到冒泡阶段</li><li>如果addEventListener第三个参数是true，那么则处于捕获阶段 document -&gt; html -&gt; body -&gt; father -&gt; son</li><li>如果addEventListener第三个参数是false或省略，那么则处于冒泡阶段 son -&gt; father -&gt; body -&gt; html -&gt; document</li></ol><h4 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4) 事件对象"></a><strong>4) 事件对象</strong></h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">div</span>.onclick = <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-keyword">event</span>)</span><span class="hljs-comment">&#123;&#125;</span><br></code></pre></td></tr></table></figure><ol><li>event就是一个事件对象，写到侦听函数的小括号里，当作形参来看</li><li>事件对象只有有了对象才会存在，它是系统自动创建的，不需要传参</li><li>事件对象是事件一系列相关数据的集合，比如鼠标点击里包含了鼠标相关的信息如鼠标坐标，键盘事件里包含键盘事件的信息比如按下了哪个键</li><li>这个事件对象可以自己命名，比如event、evt、e</li></ol><h5 id="事件对象常见的属性和方法"><a href="#事件对象常见的属性和方法" class="headerlink" title="事件对象常见的属性和方法"></a><strong>事件对象常见的属性和方法</strong></h5><table><thead><tr><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr><td>e.target</td><td>返回触发事件的对象（标准）</td></tr><tr><td>e.srcElement</td><td>返回触发事件的对象（非标准）</td></tr><tr><td>e.type</td><td>返回事件的类型 比如click moueseover 不带on</td></tr><tr><td>e.cancelBubble</td><td>该属性阻止冒泡（非标准）</td></tr><tr><td>e.returnValue</td><td>该属性阻止默认事件（默认行为）（非标准） 比如不让链接跳转</td></tr><tr><td>e.preventDefault()</td><td>该方法阻止默认事件（默认行为）（标准）比如不让链接跳转</td></tr><tr><td>e.stopPropagation()</td><td>阻止冒泡 标准</td></tr></tbody></table><h5 id="e-target和this区别"><a href="#e-target和this区别" class="headerlink" title="e.target和this区别"></a><strong>e.target和this区别</strong></h5><ol><li>e.target返回的是触发事件的对象（元素） this返回的是绑定事件的对象（元素）</li><li>区别：e.target点击了哪个元素就返回哪个元素，this哪个元素绑定了这个点击事件，那么就返回谁</li><li>currentTarget与this非常相似（区别在于有兼容性问题且不如this短）</li></ol><h4 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5) 事件委托"></a><strong>5) 事件委托</strong></h4><p>事件委托也称事件代理，再JQuery里陈伟事件委派</p><h5 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a><strong>事件委托的原理</strong></h5><p>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置的每个子节点。</p><h4 id="6-常用的鼠标事件"><a href="#6-常用的鼠标事件" class="headerlink" title="6) 常用的鼠标事件"></a><strong>6) 常用的鼠标事件</strong></h4><ol><li>禁止鼠标右键菜单contextmenu<br>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">document.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">contextmenu</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    e.prevent<span class="hljs-constructor">Default()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>禁止鼠标选中selectstart<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">document.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">selectstart</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    e.prevent<span class="hljs-constructor">Default()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a><strong>鼠标事件对象</strong></h5><table><thead><tr><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr><td>e.clientX</td><td>返回鼠标相对于浏览器窗口可视区的X坐标</td></tr><tr><td>e.clientY</td><td>返回鼠标相对于浏览器窗口可视区的Y坐标</td></tr><tr><td>e.pageX</td><td>返回鼠标相对于文档页面的X坐标</td></tr><tr><td>e.pageY</td><td>返回鼠标相对于文档页面的Y坐标</td></tr><tr><td>e.screenX</td><td>返回鼠标相对于电脑屏幕的X坐标</td></tr><tr><td>e.screenY</td><td>返回鼠标相对于电脑屏幕的Y坐标</td></tr></tbody></table><h5 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a><strong>键盘事件对象</strong></h5><table><thead><tr><th>键盘事件</th><th>触发条件</th></tr></thead><tbody><tr><td>keyup</td><td>按键弹起的时候触发</td></tr><tr><td>keydown</td><td>按键按下的时候触发</td></tr><tr><td>keypress</td><td>按键按下的时候触发 不识别功能键(ctrl shift 箭头等)</td></tr></tbody></table><table><thead><tr><th>键盘事件对象属性</th><th>说明</th></tr></thead><tbody><tr><td>keyCode</td><td>返回该键的ASCII值</td></tr><tr><td>注意：keydown和keyup不区分字母大小写，keypress区分大小写。</td><td></td></tr></tbody></table><p>实际开发中更多使用keydown和keyup，它能识别所有的键（包括功能键）</p><p>Keypress不识别功能键，但keyCode属性能区分大小写，返回不同的ASCII值</p><h3 id="4、BOM"><a href="#4、BOM" class="headerlink" title="4、BOM"></a>4、BOM</h3><p>BOM(Browser Object Model)即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window。</p><p>BOM由一些列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><p>BOM缺乏标准，由厂商定义。</p><h4 id="1-BOM的构成"><a href="#1-BOM的构成" class="headerlink" title="1) BOM的构成"></a><strong>1) BOM的构成</strong></h4><p>BOM比DOM更高级，BOM包含了DOM</p><p><img src="https://s2.loli.net/2022/03/14/dEvBQHIYaTg6P1e.png" alt="image.png"></p><ul><li>window对象是浏览器的顶级对象，它具有双重角色</li></ul><ol><li>它是JS访问浏览器的一个接口</li><li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。<br>在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等</li></ol><h4 id="2-window对象常见事件"><a href="#2-window对象常见事件" class="headerlink" title="2) window对象常见事件"></a><strong>2) window对象常见事件</strong></h4><h5 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a><strong>窗口加载事件</strong></h5><ol><li>load事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>或者<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure>window.onload是窗口（页面）加载事件，当文档内容完成加载完成会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数。</li></ol><p>2.DOMContentLoaded事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure><p>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p><p>如果页面的图片很多的话，从用户访问到onload触发可能需要较长时间，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适。</p><h5 id="调整窗口大小载事件"><a href="#调整窗口大小载事件" class="headerlink" title="调整窗口大小载事件"></a><strong>调整窗口大小载事件</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)<br>或者<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure><p>获取窗口宽高：</p><p>window.innerWidth和window.innerHeight属性</p><h4 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3) 定时器"></a><strong>3) 定时器</strong></h4><p>1.setTimeout定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//写法一，直接写函数</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;时间到了&quot;</span>)<br>&#125;,<span class="hljs-number">2000</span>);<br><span class="hljs-comment">//写法二，写函数名</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;爆炸了&quot;</span>);<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(callback,<span class="hljs-number">3000</span>);<br><span class="hljs-comment">//页面中可能会有很多的定时器，所以一般需要标识符</span><br><span class="hljs-keyword">var</span> timer1 = <span class="hljs-built_in">setTimeout</span>(函数,时间);<br></code></pre></td></tr></table></figure><p>setTimeout()这个调用函数我们称为回调函数callback</p><p>普通函数是按照代码顺序直接调用</p><p>而这个函数需要等待时间，因此称为回调函数</p><p>触发事件里的函数也是回调函数</p><ol start="2"><li><p>停止setTimeout()定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(timeoutID);<br></code></pre></td></tr></table></figure></li><li><p>setInterval定时器</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">window</span>.setIntervbal(函数,时间);<br></code></pre></td></tr></table></figure></li></ol><p>每隔多少时间就调用一次</p><ol start="4"><li><p>停止setInterval()定时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearInterval</span>()<br></code></pre></td></tr></table></figure></li><li><p>this指向（谁调用指向谁）</p></li></ol><ul><li>全局作用域或者普通函数中的this指向全局对象window（定时器里面的this指向window）</li><li>方法调用中谁调用this指向谁</li><li>构造函数中this指向构造函数的实例</li></ul><h4 id="4-JS执行机制"><a href="#4-JS执行机制" class="headerlink" title="4) JS执行机制"></a><strong>4) JS执行机制</strong></h4><h5 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a><strong>JS是单线程</strong></h5><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们堆某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a><strong>同步和异步</strong></h5><p>HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。</p><h5 id="同步："><a href="#同步：" class="headerlink" title="同步："></a><strong>同步：</strong></h5><p>前一个任务结束后执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p><h5 id="异步："><a href="#异步：" class="headerlink" title="异步："></a><strong>异步：</strong></h5><p>在做一件事情的同时，可以去处理其他事情。</p><h5 id="同步任务："><a href="#同步任务：" class="headerlink" title="同步任务："></a><strong>同步任务：</strong></h5><p>同步任务都在主线程上执行，形成一个执行栈.</p><h5 id="异步任务："><a href="#异步任务：" class="headerlink" title="异步任务："></a><strong>异步任务：</strong></h5><p>JS的异步是通过回调函数实现的。</p><p>一般而言，异步任务有以下三种类型：</p><ol><li>普通事件，如click、resize等</li><li>资源加载，如load、error等</li><li>定时器，包括setInterval、setTimeout等</li></ol><p>异步任务添加到任务队列（消息队列）里</p><h5 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a><strong>JS执行机制</strong></h5><ol><li>先执行执行栈中的同步任务</li><li>异步任务（回调函数）放入任务队列中</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</li></ol><p><img src="https://s2.loli.net/2022/03/14/mNY39ekvKwl52Fq.png" alt="image.png"></p><h4 id="5-localtion对象"><a href="#5-localtion对象" class="headerlink" title="5) localtion对象"></a><strong>5) localtion对象</strong></h4><p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。 </p><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h5><p>统一资源定位符（Uniform Resource Locator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><h5 id="location对象属性"><a href="#location对象属性" class="headerlink" title="location对象属性"></a><strong>location对象属性</strong></h5><table><thead><tr><th>location对象属性</th><th>返回值</th></tr></thead><tbody><tr><td>location.href</td><td>获取或者设置整个URL</td></tr><tr><td>location.host</td><td>返回主机（域名）</td></tr><tr><td>location.port</td><td>返回端口号，如果未写返回空字符串</td></tr><tr><td>location.pathname</td><td>返回路径</td></tr><tr><td>location.hash</td><td>返回片段 #后面的内容，常见于链接 锚点</td></tr></tbody></table><h5 id="location对象方法"><a href="#location对象方法" class="headerlink" title="location对象方法"></a><strong>location对象方法</strong></h5><table><thead><tr><th>location对象方法</th><th>返回值</th></tr></thead><tbody><tr><td>location.assign()</td><td>跟href一样，可以跳转页面（也称为重定向页面），能够后退页面</td></tr><tr><td>location.replace()</td><td>替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td>location.reload()</td><td>重新加载页面，相当于刷新按钮或者f5，如果参数为true强制刷新（ctrl+f5）</td></tr></tbody></table><h4 id="6-navigator对象"><a href="#6-navigator对象" class="headerlink" title="6) navigator对象"></a><strong>6) navigator对象</strong></h4><p>navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。</p><p>下面前端代码可以判断用户用哪个终端打开页面，实现跳转</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>((navigator.userAgent.<span class="hljs-keyword">match</span>(/(phone|<span class="hljs-type">pad</span>|<span class="hljs-type">pod</span>|<span class="hljs-type">iPhong</span>|<span class="hljs-type">iPod</span>|<span class="hljs-type">ios</span>|<span class="hljs-type">iPad</span>|<span class="hljs-type">Android</span>|<span class="hljs-type">Mobile</span>|<span class="hljs-type">BlackBerry</span>|<span class="hljs-type">IEMobile</span>|<span class="hljs-type">MQQBrowser</span>|<span class="hljs-type">JUC</span>|<span class="hljs-type">Fennec</span>|<span class="hljs-type">wOSBrowser</span>|<span class="hljs-type">BrowserNG</span>|<span class="hljs-type">WebOs</span>|<span class="hljs-type">Symbian</span>|<span class="hljs-type">Windows</span> Phone)/i)))&#123;<br>    window.location.href = <span class="hljs-string">&quot;&quot;</span>; //手机<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    window.location.href = <span class="hljs-string">&quot;&quot;</span>&#x27;; //电脑<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-history对象"><a href="#7-history对象" class="headerlink" title="7) history对象"></a><strong>7) history对象</strong></h4><table><thead><tr><th>history对象方法</th><th>作用</th></tr></thead><tbody><tr><td>back()</td><td>可实现后退功能</td></tr><tr><td>forward()</td><td>可实现前进功能</td></tr><tr><td>go(参数)</td><td>前进后退功能，参数1是前进1个页面，-1是后退1个页面</td></tr></tbody></table><h3 id="5、动画"><a href="#5、动画" class="headerlink" title="5、动画"></a>5、动画</h3><h4 id="1-节流阀"><a href="#1-节流阀" class="headerlink" title="1) 节流阀"></a><strong>1) 节流阀</strong></h4><p>防止轮播图按钮连续点击造成播放过快。</p><p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p>开始设置一个变量var flag = true;</p><p>if(flag){flag=false;do something} 关闭水龙头</p><p>利用回调函数动画执行完毕，flag = true打开水龙头</p><p>可以使用逻辑中断 flag &amp;&amp; callback()  (等同于于上面if的写法)</p><h3 id="6、本地存储"><a href="#6、本地存储" class="headerlink" title="6、本地存储"></a>6、本地存储</h3><h5 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a><strong>本地存储特性</strong></h5><ol><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，sessionStorage约5M、localStorage约20M</li><li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li></ol><h4 id="1）-window-sessionStorage"><a href="#1）-window-sessionStorage" class="headerlink" title="1） window.sessionStorage"></a><strong>1） window.sessionStorage</strong></h4><ol><li>生命周期为关闭浏览器窗口</li><li>在同一个窗口（页面）下数据可以共享</li><li>以键值对的形式存储使用</li></ol><h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a><strong>存储数据</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sessionStorage.set<span class="hljs-constructor">Item(<span class="hljs-params">key</span>,<span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a><strong>获取数据</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sessionStorage.get<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sessionStorage.remove<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="清空所有数据"><a href="#清空所有数据" class="headerlink" title="清空所有数据"></a><strong>清空所有数据</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">session.clear(); <span class="hljs-regexp">//</span>不写参数<br></code></pre></td></tr></table></figure><h4 id="2）-window-localStorage"><a href="#2）-window-localStorage" class="headerlink" title="2） window.localStorage"></a><strong>2） window.localStorage</strong></h4><ol><li>生命周期永久有效，除非手动删除否则关闭页面也会存在</li><li>可以多窗口（页面）共享（同一浏览器可以共享）</li><li>以键值对的形式存储使用</li></ol><p>使用方法与sessionStorage一致</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">localStorage.set<span class="hljs-constructor">Item(<span class="hljs-params">key</span>,<span class="hljs-params">value</span>)</span>;<br>localStorage.get<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br>localStorage.remove<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br>localStorage.clear<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语法基础</title>
    <link href="/blog/2022/03/13/JavaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2022/03/13/JavaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1、JS的书写位置"><a href="#1、JS的书写位置" class="headerlink" title="1、JS的书写位置"></a>1、JS的书写位置</h3><h5 id="1-行内式JS"><a href="#1-行内式JS" class="headerlink" title="1) 行内式JS"></a><strong>1) 行内式JS</strong></h5><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">&lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;button&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;点我&quot;</span> onclick<span class="hljs-operator">=</span><span class="hljs-string">&quot;alert(&#x27;Hello world&#x27;)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><ul><li>HTML中使用双引号，JS中使用单引号</li><li>可读性差、引号易错，不建议使用</li></ul><h4 id="2-内嵌式JS"><a href="#2-内嵌式JS" class="headerlink" title="2) 内嵌式JS"></a><strong>2) 内嵌式JS</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>最常用</li></ul><h4 id="3-外部式JS"><a href="#3-外部式JS" class="headerlink" title="3) 外部式JS"></a><strong>3) 外部式JS</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>script标签中间不可以写代码</li></ul><h3 id="2、注释写法"><a href="#2、注释写法" class="headerlink" title="2、注释写法"></a>2、注释写法</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">//单行注释</span><br><br><span class="hljs-comment">/*多行注释</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="3、JS输入输出语句"><a href="#3、JS输入输出语句" class="headerlink" title="3、JS输入输出语句"></a>3、JS输入输出语句</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>alert(msg)</td><td>浏览器弹出警示框</td></tr><tr><td>console.log(msg)</td><td>浏览器控制台打印</td></tr><tr><td>prompt(msg)</td><td>浏览器弹出输入框，取出值均为String</td></tr></tbody></table><h3 id="3、JS变量"><a href="#3、JS变量" class="headerlink" title="3、JS变量"></a>3、JS变量</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//声明<br>var age<span class="hljs-comment">;</span><br>//赋值<br><span class="hljs-attribute">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;</span><br>//变量初始化<br>var age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="声明的特殊情况"><a href="#声明的特殊情况" class="headerlink" title="声明的特殊情况"></a><strong>声明的特殊情况</strong></h5><table><thead><tr><th>情况</th><th>说明</th><th>结果</th></tr></thead><tbody><tr><td>var age;console,log(age)</td><td>只声明 不赋值</td><td>undefined</td></tr><tr><td>console.log(age)</td><td>不声明 不赋值</td><td>报错</td></tr><tr><td>age = 10; console.log(age);</td><td>不声明 只赋值</td><td>10</td></tr></tbody></table><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h5><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>Number</td><td>数字型，包含整型河浮点型</td><td>0</td></tr><tr><td>Boolean</td><td>布尔值，true/false，等价于1，0</td><td>false</td></tr><tr><td>String</td><td>字符串</td><td>“”</td></tr><tr><td>Undefine</td><td>var a; 声明但未赋值, a = undefined</td><td>undefined</td></tr><tr><td>Null</td><td>var a = null;声明了变量a为空值</td><td>null</td></tr></tbody></table><h4 id="1-Number"><a href="#1-Number" class="headerlink" title="1) Number"></a><strong>1) Number</strong></h4><h5 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a><strong>进制转换</strong></h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//<span class="hljs-number">1</span>、八进制 <span class="hljs-number">0</span>开头<br>var num1 <span class="hljs-operator">=</span> <span class="hljs-number">010</span><span class="hljs-comment">;</span><br>//<span class="hljs-number">2</span>、十六进制 <span class="hljs-number">0</span>x开头<br>var num3 <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x9<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a><strong>特殊值</strong></h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">alert</span>(Infinity); <span class="hljs-comment">//无穷大，大于任何数</span><br><span class="hljs-built_in">alert</span>(-Infinity); <span class="hljs-comment">//无穷小，小于任何数</span><br><span class="hljs-built_in">alert</span>(NaN); <span class="hljs-comment">//Not a number，代表一个非数值(仍是Number类)</span><br><br><span class="hljs-built_in">isNaN</span>() <span class="hljs-comment">//判断是否为NaN，返回true/false</span><br></code></pre></td></tr></table></figure><h4 id="2-String"><a href="#2-String" class="headerlink" title="2) String"></a><strong>2) String</strong></h4><h5 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a><strong>转义符</strong></h5><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符,n=newline</td></tr><tr><td>\</td><td>斜杆\</td></tr><tr><td>\‘</td><td>单引号</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\t</td><td>tab缩进</td></tr><tr><td>\b</td><td>空格，b=blank</td></tr></tbody></table><h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a><strong>字符串长度</strong></h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">str.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure><h5 id="字符串的性质"><a href="#字符串的性质" class="headerlink" title="字符串的性质"></a><strong>字符串的性质</strong></h5><ul><li>字符串的不可变性：<br>指的是里面的值不可变，重新赋值是地址变了，开辟了一个新的内存空间</li><li>基本包装类型：<br>可以使用.length，.indexOf()</li></ul><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a><strong>indexOf()</strong></h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Hello world&#x27;</span>;<br><span class="hljs-built_in">str</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">//从4开始往后开始找</span><br></code></pre></td></tr></table></figure><h5 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a><strong>根据位置返回字符</strong></h5><table><thead><tr><th>方法名</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>charAt(index)</td><td>返回指定位置的字符(index字符串的索引号)</td><td>str.charAt(0)</td></tr><tr><td>charCodeAt(index)</td><td>获取指定位置处字符的ASCII码</td><td>strcharCodeAt(0)</td></tr><tr><td>str[index]</td><td>获取指定位置处的字符</td><td>HTML5特性，与charAt()等效</td></tr></tbody></table><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a><strong>字符串操作</strong></h5><h5 id="拼接、截取"><a href="#拼接、截取" class="headerlink" title="拼接、截取"></a><strong>拼接、截取</strong></h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>concat(str1,str2,str3…)</td><td>等效于+</td></tr><tr><td>substr(start,length)</td><td>从start位置开始，length取的个数</td></tr><tr><td>slice(start,end)</td><td>从start位置开始，截取到end位置，end取不到[start,end)</td></tr><tr><td>substring(start,end)</td><td>基本和slice相同，但是不接受负值</td></tr></tbody></table><h5 id="替换与转数组"><a href="#替换与转数组" class="headerlink" title="替换与转数组"></a><strong>替换与转数组</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.替换字符 replace(‘被替换的字符’,<span class="hljs-string">&#x27;替换为的字符&#x27;</span>) 只会替换第一个字符<br>str.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-regexp">//</span>注意返回值为数组<br><span class="hljs-regexp">//</span>替换所有的方法<br><span class="hljs-keyword">while</span>(str.indexOf(<span class="hljs-string">&#x27;o&#x27;</span> !== -<span class="hljs-number">1</span>)&#123;<br>    str = str.replace(<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>&#125;<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.字符串转数组split(<span class="hljs-string">&#x27;分隔符&#x27;</span>)<br>str.split(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-regexp">//</span>与join转字符串相反<br></code></pre></td></tr></table></figure><h4 id="3-Undefined-amp-null"><a href="#3-Undefined-amp-null" class="headerlink" title="3) Undefined &amp; null"></a><strong>3) Undefined &amp; null</strong></h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> v = <span class="hljs-literal">undefined</span> +<span class="hljs-number">1</span>;<span class="hljs-comment">//结果为NaN</span><br><br><span class="hljs-keyword">var</span> v = <span class="hljs-literal">null</span> +<span class="hljs-number">1</span>;<span class="hljs-comment">//结果为1</span><br></code></pre></td></tr></table></figure><h4 id="4-typeof"><a href="#4-typeof" class="headerlink" title="4) typeof"></a><strong>4) typeof</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> num);<span class="hljs-comment">//无括号</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">null</span>);<span class="hljs-comment">//结果为Object</span><br></code></pre></td></tr></table></figure><h4 id="5-数据转换"><a href="#5-数据转换" class="headerlink" title="5) 数据转换"></a><strong>5) 数据转换</strong></h4><h5 id="转字符串"><a href="#转字符串" class="headerlink" title="转字符串"></a><strong>转字符串</strong></h5><table><thead><tr><th>方法</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>toString()</td><td>转字符串</td><td>var num = 1; alert(num.toString());</td></tr><tr><td>String()</td><td>强制转换字符串</td><td>var num = 1;alert(String(num));</td></tr><tr><td>加号拼接字符串</td><td>和字符串拼接的都为字符串</td><td>var num = 1;alert(num + “String”);</td></tr></tbody></table><h5 id="转数字型"><a href="#转数字型" class="headerlink" title="转数字型"></a><strong>转数字型</strong></h5><table><thead><tr><th>方法</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>parseInt(string)函数</td><td>String-&gt;Int</td><td>parseInt(‘78’)</td></tr><tr><td>parseFloat(string)函数</td><td>String-&gt;Float</td><td>parseFloat(‘72.21’)</td></tr><tr><td>Number()强制转换</td><td>String-&gt;Number</td><td>Number(‘12’)</td></tr><tr><td>js隐式转换(- * /)</td><td>利用算数运算隐式转换为数值型</td><td>‘12’ - 0</td></tr></tbody></table><h5 id="parseInt-amp-parseFloat特性"><a href="#parseInt-amp-parseFloat特性" class="headerlink" title="parseInt &amp; parseFloat特性"></a><strong>parseInt &amp; parseFloat特性</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-string">&#x27;3.94&#x27;</span>)</span></span> <span class="hljs-comment">// 3 取整，省略小数部分</span><br><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-string">&#x27;120px&#x27;</span>)</span></span> <span class="hljs-comment">//120 自动去掉数字后面的字母</span><br><span class="hljs-function"><span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-string">&#x27;rem120px&#x27;</span>)</span></span> <span class="hljs-comment">//NaN 开头必须是数字</span><br></code></pre></td></tr></table></figure><h5 id="转布尔型"><a href="#转布尔型" class="headerlink" title="转布尔型"></a><strong>转布尔型</strong></h5><p>Boolean(v)</p><ul><li>‘’、0‘NaN、null、undefined = false</li><li>其他=true</li></ul><h3 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h3><h5 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a><strong>逻辑中断</strong></h5><p>&amp;&amp; || !遇假往后，遇真中断</p><h3 id="5、流程控制"><a href="#5、流程控制" class="headerlink" title="5、流程控制"></a>5、流程控制</h3><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(条件表达式)</span></span>&#123;<br>    <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>&#123;<br>    <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><strong>switch语句</strong></h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> value1:<br>        执行语句<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> value2:<br>        执行语句<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    ....<br>    <span class="hljs-keyword">default</span>:<br>        执行最后的语句;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、循环"><a href="#6、循环" class="headerlink" title="6、循环"></a>6、循环</h3><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><strong>for循环</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++)</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><strong>while循环</strong></h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(条件表达式)</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a><strong>do while循环</strong></h5><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">do</span>&#123;<br>    循环体<br>&#125; <span class="hljs-keyword">while</span><span class="hljs-comment">(条件表达式)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、数组"><a href="#7、数组" class="headerlink" title="7、数组"></a>7、数组</h3><h5 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a><strong>数组创建</strong></h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//1、利用new创建</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>();<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//创建大小为2的数组</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Araay</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//创建内容为[2,3]的数组</span><br><span class="hljs-comment">//2、利用数组字面量创建数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h5 id="数组增加"><a href="#数组增加" class="headerlink" title="数组增加"></a><strong>数组增加</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、根据下标添加<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、使用push添加<br>arr.push(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>）直接写要添加的元素，用逗号分割<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>）push返回结果是数组长度，原数组会直接发生变化<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、使用unshift添加<br>arr,unshift(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-regexp">//</span>追加到数组最前面，返回性质与push相同<br></code></pre></td></tr></table></figure><h5 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a><strong>数组删除</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、pop删除<br>arr.pop();<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>）不跟参数，删除最后一个<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>）返回值是删除的元素<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、shift删除<br>arr.shift(); <span class="hljs-regexp">//</span>性质同上<br></code></pre></td></tr></table></figure><h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a><strong>数组排序</strong></h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//1、翻转数组</span><br>arr.<span class="hljs-built_in">reverse</span>();<br><span class="hljs-comment">//2、数组排序（冒泡排序)</span><br>arr.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">//根据先排第一位，再排第二位的方式，如[1,13,15,2,3]</span><br><br><span class="hljs-comment">//按数字大小排序方法（比较器）</span><br>arr.<span class="hljs-built_in">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>))&#123;<br>    <span class="hljs-keyword">return</span> a - b; <span class="hljs-comment">//升序排序</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a><strong>数组索引</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、indexOf()<br>arr.indexOf(<span class="hljs-string">&#x27;blue&#x27;</span>); <span class="hljs-regexp">//</span>返回数组元素的索引号，没有则返回-<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、latsIndexOf()<br>arr.lastIndexOf(); <span class="hljs-regexp">//</span>从后往前找<br></code></pre></td></tr></table></figure><h5 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a><strong>数组转字符串</strong></h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.toString()<br>arr.toString(); <span class="hljs-regexp">//</span>输出为<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>的格式<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.join(分隔符)<br>arr.join(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-regexp">//</span>改分隔符为-<br></code></pre></td></tr></table></figure><h5 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a><strong>判断是否为数组</strong></h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1</span>、instanceof运算符<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr instanceof <span class="hljs-built_in">Array</span>);<br><span class="hljs-number">2</span>、<span class="hljs-built_in">Array</span>.isArray()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray(arr));<br></code></pre></td></tr></table></figure><h3 id="8、函数"><a href="#8、函数" class="headerlink" title="8、函数"></a>8、函数</h3><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><strong>函数声明</strong></h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span>利用函数关键字自定义函数（命名函数）<br>function f1(a,b,c)&#123;<br>    <span class="hljs-comment">//函数体</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>f1();<br><br><span class="hljs-number">2.</span>函数表达式（匿名函数）<br><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//变量名，不是函数名</span><br></code></pre></td></tr></table></figure><h5 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h5><p>当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JavaScript中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">fn</span>()&#123;<br>    console<span class="hljs-selector-class">.log</span>(arguments); <span class="hljs-comment">//里面存储了所有传递过来的实参</span><br>&#125;<br><br><span class="hljs-built_in">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-comment">//打印结果</span><br><span class="hljs-built_in">Arguments</span>(<span class="hljs-number">3</span>)<span class="hljs-selector-attr">[1,2,3,calle:f,Symbol(Symbol.iterator):f]</span><br></code></pre></td></tr></table></figure><h5 id="Arguments特性："><a href="#Arguments特性：" class="headerlink" title="Arguments特性："></a><strong>Arguments特性：</strong></h5><ul><li>伪数组</li><li>1.具有length</li><li>2.按照索引的方式存储</li><li>3.没有pop()、push()等数组的方法</li><li></li></ul><h3 id="9、作用域"><a href="#9、作用域" class="headerlink" title="9、作用域"></a>9、作用域</h3><p>局部变量、全局变量</p><p>ES5中没有块级作用域，ES6中有。</p><p>块级作用域即{}内作用域，如if{} while{}等</p><h3 id="10、预解析"><a href="#10、预解析" class="headerlink" title="10、预解析"></a>10、预解析</h3><p>JS解释器执行代码分为两步：</p><p>1、预解析 把所有var和function提升到当前作用域的最前面</p><p>2、代码执行 按照代码书写顺序从上往下执行</p><p>预解析分为：</p><p>1、变量预解析（变量提升）：把变量声明提升，赋值不提升（可以调用在声明前，但值为undefined）</p><p>2、函数预解析（函数提升）：把函数声明提升，不调用函数（可以调用写在声明前）</p><h3 id="11、对象"><a href="#11、对象" class="headerlink" title="11、对象"></a>11、对象</h3><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><strong>创建对象</strong></h5><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//1、用var创建对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attribute">uname</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attribute">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attribute">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>    <span class="hljs-attribute">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//2、用 new Object创建对象</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.uname = <span class="hljs-string">&#x27;张三&#x27;</span>;<br>obj.age = <span class="hljs-number">18</span>;<br>obj.sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br>obj.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi~&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//3、构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> 构造函数名(<span class="hljs-params">属性</span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.属性 = 值；<br>    <span class="hljs-keyword">this</span>.方法 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-keyword">new</span> 构造函数名();<br><span class="hljs-comment">//构造函数的首字母必须大写</span><br></code></pre></td></tr></table></figure><h5 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a><strong>遍历对象属性</strong></h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k in obj)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(k); <span class="hljs-comment">//得到的是属性名</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj[k]);<span class="hljs-comment">//得到的是属性值</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12、内置对象"><a href="#12、内置对象" class="headerlink" title="12、内置对象"></a>12、内置对象</h3><h5 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a><strong>Math对象</strong></h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Math.<span class="hljs-literal">PI</span> <span class="hljs-comment">//圆周率，是一个属性</span><br>Math.<span class="hljs-built_in">max</span>() <span class="hljs-comment">//max方法</span><br>Math.<span class="hljs-built_in">floor</span>() <span class="hljs-comment">//向下取整</span><br>Math.<span class="hljs-built_in">ceil</span>() <span class="hljs-comment">//向上取整</span><br>Math.<span class="hljs-built_in">round</span>() <span class="hljs-comment">//四舍五入</span><br>Math.<span class="hljs-built_in">abs</span>() <span class="hljs-comment">//绝对值</span><br><br>Math.<span class="hljs-built_in">random</span>() <span class="hljs-comment">//返回一个浮点数[0,1)</span><br></code></pre></td></tr></table></figure><h5 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a><strong>Date对象</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//Date()日期对象 是一个构造函数 必须用new来调用创建</span><br>var date = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Data()</span>;<br>date.get<span class="hljs-constructor">FullYear()</span> <span class="hljs-comment">//获取当年</span><br>date.get<span class="hljs-constructor">Month()</span> <span class="hljs-comment">//获取当月（0-11）</span><br>date.get<span class="hljs-constructor">Date()</span> <span class="hljs-comment">//获取当天日期</span><br>date.get<span class="hljs-constructor">Day()</span> <span class="hljs-comment">//获取星期几（周日0-周六6）</span><br>date.get<span class="hljs-constructor">Hours()</span> <span class="hljs-comment">//获取当前小时</span><br>date.get<span class="hljs-constructor">Minutes()</span> <span class="hljs-comment">//获取当前分钟</span><br>date.get<span class="hljs-constructor">Seconds()</span> <span class="hljs-comment">//获取当前秒</span><br><br><span class="hljs-comment">//获取时间戳</span><br>date.value<span class="hljs-constructor">Of()</span><br>date.get<span class="hljs-constructor">Time()</span><br>var date1 = +<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>;<br></code></pre></td></tr></table></figure><h3 id="13、基本包装类型"><a href="#13、基本包装类型" class="headerlink" title="13、基本包装类型"></a>13、基本包装类型</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;andy&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str.<span class="hljs-built_in">length</span>);<br></code></pre></td></tr></table></figure><p>按道理基本数据类型没有属性和方法，而对象才有，以上代码可以执行是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下：(String、Number、Boolean都会进行包装)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//1、生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="hljs-built_in">var</span> temp = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&#x27;andy&#x27;</span>);<br><span class="hljs-comment">//2、赋值给我们声明的字符变量</span><br><span class="hljs-built_in">str</span> = temp;<br><span class="hljs-comment">//3、销毁临时变量</span><br>temp = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h3 id="14、简单数据类型与复杂类型"><a href="#14、简单数据类型与复杂类型" class="headerlink" title="14、简单数据类型与复杂类型"></a>14、简单数据类型与复杂类型</h3><h5 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a><strong>值类型与引用类型</strong></h5><ul><li>值类型：简单数据类型/基本数据类型，再存储时变量中存储的是值本身</li></ul><p>string, number , boolean, undefined, null</p><ul><li>引用类型：复杂数据类型，再存储变量中存储的是仅仅是地址（引用）</li></ul><p>通过new关键字创建的对象，如Object、Array、Date等</p><h5 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a><strong>堆和栈</strong></h5><p>1、栈（操作系统）：用操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；简单数据类型存放在栈中</p><p>2、堆（操作系统）：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构与算法】一、排序算法</title>
    <link href="/blog/2022/03/12/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/blog/2022/03/12/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><h3 id="1-异或运算"><a href="#1-异或运算" class="headerlink" title="1. 异或运算^"></a>1. 异或运算^</h3><p>二进制中相同为1，不同为0，可以理解为无进位相加</p><p>性质：</p><ul><li>0 ^ N = N 、N ^ N = 0</li><li>交换律：a ^ b = b ^ a</li><li>结合律：a ^ b ^ c = a ^ (b ^ c) 运算顺序不影响结果</li></ul><h5 id="交换两个数-swap"><a href="#交换两个数-swap" class="headerlink" title="交换两个数(swap)"></a>交换两个数(swap)</h5><p>注意：只能在保证每个数都不一样的情况下使用，否则会把数字变成0（任何数异或自己等于0）</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">if (arr[i] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> arr[j])&#123;return<span class="hljs-comment">;&#125; //保证两个数不一样</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">// a = 甲 ^ 乙</span><br>    arr[j] = arr[i] ^ arr[j]; <span class="hljs-comment">//b = 甲 ^ 乙 ^ 乙 = 甲</span><br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">//a = 甲 ^ 乙 ^ 甲 = 乙</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="异或例题：找出数组中出现奇数次的数"><a href="#异或例题：找出数组中出现奇数次的数" class="headerlink" title="异或例题：找出数组中出现奇数次的数"></a>异或例题：找出数组中出现奇数次的数</h5><p>1、数组中有一个数出现了奇数次，其他出现了偶数次</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">FindOddTimesNum1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> oddNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (cur : arr)&#123;<br>        oddNum ^= cur; <span class="hljs-comment">//全部异或，得到结果</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> oddNum;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、数组中有两个数出现了奇数次，其他出现了偶数次</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static int FindOddTimesNum2(int[] arr)&#123;<br>    int oddNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(cur : arr)&#123;<br>        oddNum ^= cur;<br>    &#125;<br>    <span class="hljs-regexp">//</span>重复上一步，得到oddNum = a ^ b<br>    <span class="hljs-regexp">//</span>因为两个数不一样，所以其中必有一位是<span class="hljs-number">1</span><br>    <br>    <span class="hljs-regexp">//</span>提取出<span class="hljs-number">1</span>的位置<br>    int pos = oddNum &amp; (~oddNum + <span class="hljs-number">1</span>)<br>    <span class="hljs-regexp">//</span>例 oddNum = <span class="hljs-number">1001</span><br>    <span class="hljs-regexp">//</span>~oddNum = <span class="hljs-number">0110</span><br>    <span class="hljs-regexp">//</span>~oddNum + <span class="hljs-number">1</span> = <span class="hljs-number">0111</span><br>    <span class="hljs-regexp">//</span>oodNum &amp; (~oddNum + <span class="hljs-number">1</span>) = <span class="hljs-number">0001</span><br>    <span class="hljs-regexp">//</span>这样提取出来就是最右边是<span class="hljs-number">1</span>的一位还是<span class="hljs-number">1</span>，其他位置上都为<span class="hljs-number">0</span><br>    <br>    int oddNum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(cur : arr)&#123;<br>        <span class="hljs-keyword">if</span>((cur &amp; pos) == <span class="hljs-number">0</span>)&#123; <span class="hljs-regexp">//</span>因为pos其他位都是<span class="hljs-number">0</span>，&amp;结果一定是<span class="hljs-number">0</span>不用管，如果结果=<span class="hljs-number">0</span>那么说明这个数在这个<span class="hljs-number">1</span>位置上也是<span class="hljs-number">0</span>，可以改写成 (cur &amp; pos) == pos<br>            oddNum2 ^= cur;<br>        &#125;<br>    System.out.println(oddNum2 + <span class="hljs-string">&quot; &quot;</span> + (oddNum ^ oddNum2))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-简单排序"><a href="#2-简单排序" class="headerlink" title="2. 简单排序"></a>2. 简单排序</h3><h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1)选择排序"></a>1)选择排序</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-comment">//排除空数组或过小数组</span><br>    <span class="hljs-keyword">if</span>(arr == null || arr.length&lt;<span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span>;&#125; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length - <span class="hljs-number">1</span>;i++)&#123; <span class="hljs-comment">//i ~ N-1</span><br>         <span class="hljs-type">int</span> minIndex = i;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++)&#123; <span class="hljs-comment">//i ~ N - 1上找最小值的下标</span><br>            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; <br>            &#125;<br>            <span class="hljs-built_in">swap</span>(arr,i,minIndex); <span class="hljs-comment">//交换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2)冒泡排序"></a>2)冒泡排序</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-comment">//去掉不合适的数组</span><br>        <span class="hljs-keyword">if</span> (arr == null || arr.length &lt; <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = arr.length - <span class="hljs-number">1</span>; len &gt; <span class="hljs-number">0</span>; len--)&#123; <span class="hljs-comment">//每次循环确定最后一个值，i的循环最大值前移一位</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>                <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>])&#123; <span class="hljs-comment">//前一个比后一个大，往上冒泡</span><br>                    <span class="hljs-built_in">swap</span>(arr,i,i+<span class="hljs-number">1</span>); <span class="hljs-comment">//交换</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3)插入排序"></a>3)插入排序</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">public static void <span class="hljs-built_in">InsertionSort</span>(int[] arr)&#123;<br>    <span class="hljs-comment">//去掉不合适的数组</span><br>    if (arr == null || arr.length &lt; <span class="hljs-number">2</span>)&#123;return;&#125;<br><br>    <span class="hljs-built_in">for</span>(int i = <span class="hljs-number">1</span>; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-built_in">for</span>(int j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-built_in">if</span>(arr[j] &gt;  arr[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(arr,j,j+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-递归行为"><a href="#3-递归行为" class="headerlink" title="3.递归行为"></a>3.递归行为</h3><h4 id="1、时间复杂度分析"><a href="#1、时间复杂度分析" class="headerlink" title="1、时间复杂度分析"></a>1、时间复杂度分析</h4><p>master公式：<br>T(N) = a * T(N/b) + O(N^d^)</p><p>log<del>b</del>a &lt; d  O(N^d^)</p><p>log<del>b</del>a &gt; d  O(N^log<del>b</del>a^)</p><p>log<del>b</del>a == d  O(N^d^ * logN)</p><h4 id="2、寻找最大值"><a href="#2、寻找最大值" class="headerlink" title="2、寻找最大值"></a>2、寻找最大值</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<span class="hljs-keyword">return</span> arr[L];&#125;<br>    <span class="hljs-keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//直接计算Mid可以是(L+R)/2，但在极端情况下R会过大导致没法计算，因此可以改写成L + (R-L)/2，然后&gt;&gt;1意为右移一位，等同于除2</span><br>    <span class="hljs-keyword">int</span> leftMax = process(arr,L,mid);<br>    <span class="hljs-keyword">int</span> rightMax = process(arr,mid + <span class="hljs-number">1</span>,R);<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> Math.<span class="hljs-title">max</span><span class="hljs-params">(leftMax,rightMax)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、归并排序"><a href="#3、归并排序" class="headerlink" title="3、归并排序"></a>3、归并排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R-L)&gt;&gt;<span class="hljs-number">1</span>);<br>    MergeSort(arr,L,mid);<br>    MergeSort(arr,mid + <span class="hljs-number">1</span>,R);<br>    merge(arr,L,mid,R);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M　+ <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= M)&#123;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= M)&#123;<br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p2 &lt;= M)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>        arr[L + i] = help[i];<br>    &#125;<br><br>&#125; <br></code></pre></td></tr></table></figure><h5 id="1-求小和问题"><a href="#1-求小和问题" class="headerlink" title="1)求小和问题"></a>1)求小和问题</h5><p>求出每个数左边比这个数小的和，全部相加为整个数组的小和</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> void MergeSort(int[] arr,int L,<span class="hljs-built_in"> int </span>R)&#123;<br>    if(<span class="hljs-class">L==R)&#123;return 0 ;</span>&#125;<br>   <span class="hljs-built_in"> int </span>mid = L + ((R-<span class="hljs-class">L)&gt;&gt;1);</span><br>   <span class="hljs-built_in"> return </span>MergeSort(arr,<span class="hljs-class">L,mid);</span> //返回左边小和+右边小和+所有小和(即右组对左组)<br>    + MergeSort(arr,mid + 1,R);<br>    + merge(arr,<span class="hljs-class">L,mid,R);</span><br>&#125;<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> void merge(int[] arr,<span class="hljs-built_in"> int </span>L,<span class="hljs-built_in"> int </span>M,<span class="hljs-built_in"> int </span>R)&#123;<br>    int[] help =<span class="hljs-built_in"> new </span>int[R - <span class="hljs-class">L + 1];</span><br>   <span class="hljs-built_in"> int </span>i = 0;<br>   <span class="hljs-built_in"> int </span>p1 = <span class="hljs-class">L;</span><br>   <span class="hljs-built_in"> int </span>p2 = M　+ 1;<br>   <span class="hljs-built_in"> int </span>res = 0; //记录小和<br>    while(p1 &lt;= M &amp;&amp; p2 &lt;= M)&#123;<br>    res += arr[p1] &lt; arr[p2] ? (r - p2 +1) * arr[p1]<span class="hljs-keyword"> :</span> 0;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++]<span class="hljs-keyword"> :</span> arr[p2++];<br>    &#125;<br>    while(p1 &lt;= M)&#123;<br>        help[i++] = arr[p1++];<br>    &#125;<br>    while(p2 &lt;= M)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    for (i = 0; i &lt; help.length; i++)&#123;<br>        arr[<span class="hljs-class">L + i] = help[i];</span><br>    &#125;<br>   <span class="hljs-built_in"> return </span>res; //返回小和<br><br>&#125; <br></code></pre></td></tr></table></figure><h4 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h4><h5 id="1-荷兰国旗问题"><a href="#1-荷兰国旗问题" class="headerlink" title="1)荷兰国旗问题"></a><strong>1)荷兰国旗问题</strong></h5><p><strong>一、给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。额外空间复杂度O(1)，时间复杂度O(N)</strong></p><p>思路：</p><p>变量left代表左边界，i指向当前位置</p><ol><li>[i] &lt;= num，和left+1交换，left++，i++</li><li>[i] &gt; num, i++</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Holland</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= num)&#123;<br>            <span class="hljs-built_in">swap</span>(arr,i,left++);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，大于num的数放在数组的右边，等于num的数放在数组中间。额外空间复杂度O(1)，时间复杂度O(N)</strong></p><p>思路：</p><p>变量left代表左边界，right代表右边界，i指向当前位置</p><ol><li>[i] &lt; num，和left+1交换，left++，i++</li><li>[i] == num，i++</li><li>[i] &gt; num，和right-1交换，right–，i不变</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Holland2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = arr.length;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; num)&#123;<br>            <span class="hljs-built_in">swap</span>(arr,i++,++left);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &gt; num)&#123;<br>            <span class="hljs-built_in">swap</span>(arr,i,--right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-快速排序quicksort"><a href="#2-快速排序quicksort" class="headerlink" title="2)快速排序quicksort"></a><strong>2)快速排序quicksort</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void quick<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> L, <span class="hljs-params">int</span> R)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L &lt; R)&#123;<br>        swap(arr,L + (<span class="hljs-built_in">int</span>) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>(R - L + <span class="hljs-number">1</span>)), R);<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> p = partition(arr, L, R);<br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, L, <span class="hljs-params">p</span>[0] - 1)</span>; <span class="hljs-comment">//左区</span><br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">p</span>[1] + 1, R)</span>; <span class="hljs-comment">//右区</span><br>    &#125;<br>&#125;<br><br>public static <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> partition(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr, <span class="hljs-built_in">int</span> L, <span class="hljs-built_in">int</span> R)&#123;<br>    <span class="hljs-built_in">int</span> less = L - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> more = R;<br>    <span class="hljs-keyword">while</span>(L &lt; more)&#123;<br>        <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[L]</span> &lt; arr<span class="hljs-literal">[R]</span>)&#123;<br>            swap(arr, ++less, L++);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[L]</span> &gt; arr<span class="hljs-literal">[R]</span>)&#123;<br>            swap(arr, --more, L);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            L++;<br>        &#125;<br>    &#125;<br>    swap(arr, more, R);<br>    return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> &#123;less + <span class="hljs-number">1</span>, more&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h3><h4 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="1)完全二叉树"></a><strong>1)完全二叉树</strong></h4><p>从左往右依次填的树就是完全二叉树</p><p>父节点 (i - 1) / 2</p><p>左子 2 * i + 1</p><p>右子 2 * i+2</p><h4 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2)堆排序"></a><strong>2)堆排序</strong></h4><p>每一个子树的头节点是最大值/最小值的称为大/小根堆</p><h5 id="插入堆heapInsert，把下面的数往上移"><a href="#插入堆heapInsert，把下面的数往上移" class="headerlink" title="插入堆heapInsert，把下面的数往上移"></a><strong>插入堆heapInsert，把下面的数往上移</strong></h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> heapInsert(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)&#123;<br>    <span class="hljs-comment">//1、当比父节点大时就执行交换，小于等于父节点就跳出while</span><br>    <span class="hljs-comment">//2、当index=0时，就变成了自己跟自己比，也会停止</span><br>    <span class="hljs-keyword">while</span>(arr[<span class="hljs-keyword">index</span>] &gt; arr[(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] )&#123;<br>        swap(arr,<span class="hljs-keyword">index</span>,(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">index</span> = (<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="堆化数组heapify，把上面的数往下移"><a href="#堆化数组heapify，把上面的数往下移" class="headerlink" title="堆化数组heapify，把上面的数往下移"></a><strong>堆化数组heapify，把上面的数往下移</strong></h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> heapify(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-built_in">int</span> heapSize)&#123; <span class="hljs-comment">//heapSize用来记录堆的边界</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-keyword">index</span> * <span class="hljs-number">2</span> +<span class="hljs-number">1</span>; <span class="hljs-comment">//左子下标</span><br>    <span class="hljs-keyword">while</span>(left &lt; heapSize)&#123; <span class="hljs-comment">//先判断下方有无孩子，因为右一定大于左所以只判断左</span><br>    <br>    <span class="hljs-comment">//两个孩子谁大把下标给largest</span><br>    <span class="hljs-comment">//右儿子存在 &amp;&amp; 右子比左子大 ? 右子 : 左子</span><br>    <span class="hljs-built_in">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>    <br>    <span class="hljs-comment">//父与子直接谁大把下标给largest</span><br>    largest = arr[largest] &gt; arr[<span class="hljs-keyword">index</span>] ? largest : <span class="hljs-keyword">index</span>;<br>    <br>    <span class="hljs-keyword">if</span>(largest == <span class="hljs-keyword">index</span>)&#123; <span class="hljs-comment">//没比过就跳出了</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    swap(arr, largest, <span class="hljs-keyword">index</span>); <span class="hljs-comment">//子大那就交换</span><br>    <span class="hljs-keyword">index</span> = largest;<br>    left = <span class="hljs-keyword">index</span> * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="堆排序heapSort"><a href="#堆排序heapSort" class="headerlink" title="堆排序heapSort"></a><strong>堆排序heapSort</strong></h5><ol><li>依次执行heapInsert，完成数组堆化</li><li>把heapSize位置的数跟0位置交换，heapSize–，此时最大值到最后位置且与heap断连</li><li>对0位置执行heapify，保持数组为大根堆</li><li>重复操作2-3，当heapSize==0时，排序完成<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == null || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123; <span class="hljs-comment">//O(N)</span><br>        <span class="hljs-comment">//把每个数依次执行插入堆，完成数组堆化</span><br>        <span class="hljs-built_in">heapInsert</span>(arr,i); <span class="hljs-comment">// O(logN)</span><br>    &#125;<br>    <span class="hljs-type">int</span> heapSize = arr.length;<br>    <span class="hljs-built_in">swap</span>(arr,<span class="hljs-number">0</span>,--heapSize);<br>    <span class="hljs-keyword">while</span>(heapSize &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//时间复杂度O(N)</span><br>        <span class="hljs-built_in">heapify</span>(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">//O(logN)</span><br>        <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span> , --heapSize); <span class="hljs-comment">//O(1)</span><br>    &#125;<br>    <br></code></pre></td></tr></table></figure>只让数组变成大根堆的方法：</li></ol><p>倒过来，从后往前使用heapify</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    <span class="hljs-built_in">heapify</span>(arr, i, arr.length);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="小根堆（优先级队列）"><a href="#小根堆（优先级队列）" class="headerlink" title="小根堆（优先级队列）"></a><strong>小根堆（优先级队列）</strong></h5><ul><li>有缺点：中间的数弹出很低效，有需要中间数操作的手写堆，只需要头尾操作的可以用黑盒<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">PriorityQueue&lt;<span class="hljs-type">Integer</span>&gt; heap = <span class="hljs-built_in">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-keyword">while</span>(!heap.isEmpty())&#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(heap.poll());//每次弹出的就是最大值<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="比较器概念"><a href="#比较器概念" class="headerlink" title="比较器概念"></a><strong>比较器概念</strong></h5><ul><li>等同于C++重载比较运算符<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>    <span class="hljs-comment">//返回负数的时候，第一个参数排前面</span><br>    <span class="hljs-comment">//返回正数，第二个数排前面</span><br>    <span class="hljs-comment">//返回0，无所谓</span><br>    <span class="hljs-meta">@Override</span><br>    pubic <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student <span class="hljs-number">01</span>, Student <span class="hljs-number">02</span>)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">01.</span>id - o2.id;<br>    &#125;<br>&#125;<br><br>Arrays.sor(students,<span class="hljs-keyword">new</span> IdAscendingComparator())<br></code></pre></td></tr></table></figure></li></ul><h5 id="利用比较器，实现黑盒大根堆排序"><a href="#利用比较器，实现黑盒大根堆排序" class="headerlink" title="利用比较器，实现黑盒大根堆排序"></a><strong>利用比较器，实现黑盒大根堆排序</strong></h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-keyword">class</span> Acomp implements Comparator&lt;<span class="hljs-type">Integer</span>&gt;&#123;<br>    @opverride<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(<span class="hljs-type">Integer</span> arg0, <span class="hljs-type">Integer</span> arg1)&#123;<br>        <span class="hljs-keyword">return</span> arg1 - arg0;<br>        &#125;<br>    &#125;<br>    <br>    PriorityQueue&lt;<span class="hljs-type">Integer</span>&gt; heap = <span class="hljs-built_in">new</span> PriorityQueue&lt;&gt;(<span class="hljs-built_in">new</span> Acomp());<br>    <span class="hljs-keyword">while</span>(!heap.isEmpty())&#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(heap.poll());//每次弹出的就是最小值<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="5-不基于比较的排序"><a href="#5-不基于比较的排序" class="headerlink" title="5.不基于比较的排序"></a>5.不基于比较的排序</h3><ul><li>必须根据数据状况定制，没那么好用</li></ul><h5 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><strong>计数排序</strong></h5><p>统计词频</p><h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h5><ul><li>排的数据必须有进制</li></ul><ol><li>把所有数字的位数统一到跟最多位的数一样，如[2,100] -&gt; [002,100]</li><li>根据末位数字堆到对应数字的桶里</li><li>先进先出，把数字倒出来</li><li>根据倒数第二位数字堆到对应数字桶里</li><li>先进先出，把数字倒出来</li><li>重复操作，把所有位排完数组就有序了</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void radix<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        return;<br>    &#125;radix<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>,0,<span class="hljs-params">arr</span>.<span class="hljs-params">length</span> - 1,<span class="hljs-params">maxbits</span>(<span class="hljs-params">arr</span>)</span>);<br>    &#125;<br><br>public static <span class="hljs-built_in">int</span> maxbits(<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr)&#123;<br>    <span class="hljs-built_in">int</span> max = Integer.MIN_Value;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>        max = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(max,arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>    &#125;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(max != <span class="hljs-number">0</span>)&#123;<br>        res++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    return res;<br>&#125;<br><br>public static void radix<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> L, <span class="hljs-params">int</span> R, <span class="hljs-params">int</span> <span class="hljs-params">digit</span>)</span>&#123;<br>    final <span class="hljs-built_in">int</span> radix = <span class="hljs-number">10</span>; <span class="hljs-comment">//以10为基底，即所有数都是10进制</span><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//有多少个数准备多少个辅助空间</span><br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[R - L + <span class="hljs-number">1</span>]</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++)&#123; <span class="hljs-comment">//有多少位就进出多少次</span><br>        <span class="hljs-comment">//10个空间</span><br>        <span class="hljs-comment">//count[0]当前位(d位)是0的数字有多少个</span><br>        <span class="hljs-comment">//count[1]当前位(d位)是(0和1)的数字有多少个</span><br>        <span class="hljs-comment">//count[2]当前位(d位)是(0、1和2)的数字有多少个</span><br>        <span class="hljs-comment">//count[i]当前位(d位)是(o~i)的数字有多少个</span><br>        <span class="hljs-comment">//相当于先每个位置词频统计，再在每一位上把把前面的从词频累加</span><br>        <span class="hljs-comment">//于是开始从后往前遍历数组，count里的数是多少，就说明在这个数前面有几个数，count里的这个值就是数应该在桶里的位置</span><br>        <br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">radix</span>]</span>; <span class="hljs-comment">//count[0..9]</span><br>        <span class="hljs-comment">//词频统计</span><br>        <span class="hljs-keyword">for</span>(i = L; i &lt;= R; i++)&#123;<br>            j = get<span class="hljs-constructor">Digit(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>], <span class="hljs-params">d</span>)</span>;<br>            count<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>++;<br>        &#125;<br>        <span class="hljs-comment">//累加</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; radix; i++)&#123;<br>            count<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = count<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> + count<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>;<br>        &#125;<br>        <span class="hljs-comment">//进桶，根据对应位置count得出该在的位置，进桶后该位置count--</span><br>        <span class="hljs-keyword">for</span>(i = R; i &gt;= L; i--)&#123;<br>            j = get<span class="hljs-constructor">Digit(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>], <span class="hljs-params">d</span>)</span>;<br>            bucket<span class="hljs-literal">[<span class="hljs-identifier">count</span>[<span class="hljs-identifier">j</span>]</span> - <span class="hljs-number">1</span>]  = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            count<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++)&#123;<br>            arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = bucket<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//提取出指定位置的数字</span><br>public static <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Digit(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">d</span>)</span>&#123;<br>    return ((x<span class="hljs-operator"> / </span>((<span class="hljs-built_in">int</span>) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>选择</td><td>O(n^2^)</td><td>o(1)</td><td>×</td></tr><tr><td>冒泡</td><td>O(N^2^)</td><td>O(1)</td><td>√</td></tr><tr><td>插入</td><td>O(N^2^)</td><td>O(1)</td><td>√</td></tr><tr><td>归并</td><td>O(N*logN)</td><td>O(N)</td><td>√</td></tr><tr><td>快排(随机p)</td><td>O(N*lognN)</td><td>O(logN)</td><td>×</td></tr><tr><td>堆</td><td>O(N*logN)</td><td>O(1)</td><td>×</td></tr><tr><td>总结：能用快排用快排，空间不够用堆排，需要稳定性用归并</td><td></td><td></td><td></td></tr></tbody></table><p>基于比较的排序：</p><ol><li>时间复杂度小于O(N*logN)不存在</li><li>在时间复杂度在O(N*logN)的情况下，空间复杂度在O(N)以下且保持稳定性不存在</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo搭建博客及配置</title>
    <link href="/blog/2020/11/23/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2020/11/23/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    对于一个程序员来说，平常学习的过程中肯定少不了看各种博客，比如CSDN、简书之余，看久了自然而然也有搭建自己的博客的想法，简单的方法可以借助上述的平台，如果不怕折腾的话也可以自己搭建一个，更加自由不受限制，这篇文章就是记录了我自己搭建博客的全过程，希望能对有想法的人提供一些帮助。</p><h2 id="一、事前准备"><a href="#一、事前准备" class="headerlink" title="一、事前准备"></a>一、事前准备</h2><h4 id="1-创建Github-域名和仓库"><a href="#1-创建Github-域名和仓库" class="headerlink" title="1. 创建Github 域名和仓库"></a>1. 创建Github 域名和仓库</h4><p>首先需要一个<a href="https://github.com/">GitHub</a>账号，如何注册就不再赘述了。</p><p>然后需要创建一个仓库(repository) 来存储我们的网站，点击首页的 <code>New</code>按钮创建仓库：</p><p><img src="https://s2.loli.net/2022/03/15/jmg58KqkM293zDS.png" alt="image.png"></p><p>Respository name 的命名格式为<code>username</code>.github.io，其中<code>username</code> 一定与前面的Owner 一致，这里我已经创建过了。</p><p><img src="https://s2.loli.net/2022/03/15/u2twTqPBbNHr7vo.png" alt="image.png"></p><h3 id="2-服务器（可选）"><a href="#2-服务器（可选）" class="headerlink" title="2.服务器（可选）"></a>2.服务器（可选）</h3><p>因为网站借助了GitHub page，所以不用租赁服务器也是可以搭建完成博客的，所以这里就看自己需求吧，如果用的是自己的电脑可以略过这一步了。</p><p>我使用的是阿里云的学生服务器，配置非常简单，一核CPU，2GB内存，1Mbps带宽，CentOS7.3系统，因为是学生优惠，价格非常美丽，只需要9.8￥/月，仅用作博客还是够用的。</p><p>首先用Shell工具连接上你的服务器实例，我使用的是FinalShell。</p><p><img src="https://s2.loli.net/2022/03/15/2cbjw6xvi7Cg1zE.png" alt="image.png"></p><p>连接完成后，进行下一步。</p><h3 id="3-安装需要的工具"><a href="#3-安装需要的工具" class="headerlink" title="3.安装需要的工具"></a>3.安装需要的工具</h3><p>需要安装的工具包括：Git, Nodejs, Hexo</p><h4 id="3-1安装Git"><a href="#3-1安装Git" class="headerlink" title="3.1安装Git"></a>3.1安装Git</h4><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。这里是用来上传你的Hexo博客文章到GitHub page的工具。</p><p>因为我使用的系统是CentOS，所以直接使用yum命令安装，其他系统请自行百度如何安装</p><p><code>sudo yum install git</code></p><h4 id="3-2安装Nodejs"><a href="#3-2安装Nodejs" class="headerlink" title="3.2安装Nodejs"></a>3.2安装Nodejs</h4><p>由于我们搭建博客所需要的Hexo是基于Nodejs的，所以我们需要先安装配置好Nodejs环境。</p><p>首先前往<a href="https://nodejs.org/en/download/">Nodejs官网</a>，根据自己系统下载对应的安装包。</p><p>我这里下载的是Linux 64位版本，下载后得到<code>node-v14.15.1-linux-x64.tar.xz</code>文件，将文件用FTP传输到服务器上，我这里使用FinalShell直接拖动进文件夹即可。（后来发现这里使用该版本的Nodejs会出问题，所以建议使用低版本，我使用的是12.14.0）<img src="https://s2.loli.net/2022/03/15/unJqrPVAtYCkOBd.png" alt="image.png"></p><p>然后解压文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/root/dowload</span><br>tar -xvf *<span class="hljs-string">.xz</span><br></code></pre></td></tr></table></figure><p>解压完成后将整个文件夹移动到/usr/local/nodejs里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local<br><span class="hljs-built_in">mkdir</span> nodejs<br><span class="hljs-built_in">cd</span> nodejs<br><span class="hljs-built_in">mv</span> /root/dowlad/nodde-v14.15.1-linux-x64 .<br></code></pre></td></tr></table></figure><p>然后创建软链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>bin<span class="hljs-regexp">/npm /u</span>sr<span class="hljs-regexp">/local/</span>bin/<br>ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>bin<span class="hljs-regexp">/nodejs /u</span>sr<span class="hljs-regexp">/local/</span>bin/<br></code></pre></td></tr></table></figure><p>查看一下npm和nodejs的版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/15/3OwEWroQtZlA7sI.png" alt="image.png"></p><p>都没有问题，安装成功。</p><h4 id="3-3安装Hexo"><a href="#3-3安装Hexo" class="headerlink" title="3.3安装Hexo"></a>3.3安装Hexo</h4><p>前面都安装完毕后可以开始安装Hexo了，这里可以先建一个blog文件夹，cd到该文件夹下再进行操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>local<br>mkdir blog<br>cd blog<br>npm install -g hexo-cli<br>ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/blog/</span>node_modules<span class="hljs-regexp">/hexo/</span>bin<span class="hljs-regexp">/hexo /u</span>sr<span class="hljs-regexp">/local/</span>bin<br></code></pre></td></tr></table></figure><p>很快就安装完了，接下来初始化Hexo</p><p><code>hexo init</code></p><p>然后就生成了一堆文件</p><p><img src="https://s2.loli.net/2022/03/15/li1Fmh4k72RWAor.png" alt="image.png"></p><p>文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li> _config.yml: 博客的配置文件</li></ul><h3 id="4-生成SSH添加到GitHub"><a href="#4-生成SSH添加到GitHub" class="headerlink" title="4.生成SSH添加到GitHub"></a>4.生成SSH添加到GitHub</h3><p>首先输入你的GitHub用户名和邮箱，对应下面的yourname和youremail</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>然后创建SSH，这里三个选项直接回车即可</p><p><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></p><p>这个时候会提示已经生成了.ssh文件夹，根据给你的路径找到这个文件夹下。</p><p>其中，<code>id_rsa</code>是你这台电脑的私钥，不能给别人看，id_rsa.pub是公钥，打开复制里面的内容到GitHub的账户上。</p><p><img src="https://s2.loli.net/2022/03/15/WOBtkKJmFTaR3Nn.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/15/1Qds9tuB8bmxGV7.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/15/ko4XSML6V7bP1uq.png" alt="image.png"></p><p>将内容直接复制进去提交即可。</p><h3 id="5-hexo配置"><a href="#5-hexo配置" class="headerlink" title="5.hexo配置"></a>5.hexo配置</h3><p>首先需要将hexo部署到之前创建好的GitHub仓库上。</p><p>打开<code>_config.yml</code>，翻到最后一部分，按如下格式修改内容，其中yourgithubName就是你的GitHub用户名</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:YourgithubName/YourgithubName.github.io<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>然后安装一个deploy-git，这样才能部署到GitHub。</p><p><code>npm install hexo-deployer-git --save</code></p><p>然后运行</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure><p>就搭建完成啦！</p><p>直接访问<code>YourgithubName.github.io</code>就可以看到已经搭建完成的静态网页了</p><p>再打开打开<code>_config.yml</code>进行一些需要设置，这里罗列一些比较常用的供大家参考</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">title: <span class="hljs-string">&#x27;BETA的技术分享小站&#x27;</span> <span class="hljs-regexp">//</span>博客的标题<br>subtitle: <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-regexp">//</span>博客的子标题<br>description: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span>博客的描述<br>author: BETA  <span class="hljs-regexp">//</span>博客的作者<br>language: zh-Hans <span class="hljs-regexp">//</span>语言，根据主题来，与主题对应语言的语言包文件名需一致<br>timezone: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span>时区，一般默认设置即可<br></code></pre></td></tr></table></figure><h3 id="6-开始愉快的写文章"><a href="#6-开始愉快的写文章" class="headerlink" title="6.开始愉快的写文章"></a>6.开始愉快的写文章</h3><p>直接执行</p><p><code>hexo new test</code></p><p>会在<code>source/_post</code>中生成名为<code>test</code>的markdown文件，编辑完成后再执行一遍</p><p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><p>就可以在博客上看到相应的文章了</p><h2 id="二、主题美化"><a href="#二、主题美化" class="headerlink" title="二、主题美化"></a>二、主题美化</h2><p>默认的主题比较拉跨，所以一般来说仍需要我们做进一步的美化。</p><p>我使用的是Next主题，这也是用的人比较多的的一个主题，直接使用下面这行指令安装即可。</p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>安装完成后我们需要更改一些设置，先打开<code>_config.yml</code></p><p>更改如下条目</p><p><code>theme: next</code></p><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/4eaddcbe4d12">https://www.jianshu.com/p/4eaddcbe4d12</a> 5分钟 搭建免费个人博客</p><p><a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a> Hexo的Next主题详细配置</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空调房</title>
    <link href="/blog/2020/11/23/%E7%A9%BA%E8%B0%83%E6%88%BF/"/>
    <url>/blog/2020/11/23/%E7%A9%BA%E8%B0%83%E6%88%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>炎炎夏日如何度过?BETA的技术小站持续为您提供空调服务，欢迎在此小憩一番。</p></blockquote><iframe height="740" width="100%" src="https://ac.yunyoujun.cn"></iframe>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
